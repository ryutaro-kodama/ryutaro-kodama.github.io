<!DOCTYPE html>
<html>

<head>
	<title></title>
	<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
	<link rel="stylesheet" type="text/css" href="https://ryutaro-kodama.github.io/slides/style/heading.css" />
	<link rel="stylesheet" type="text/css" href="https://ryutaro-kodama.github.io/slides/style/common.css" />
	<link rel="stylesheet" type="text/css" href="https://ryutaro-kodama.github.io/slides/style/code.css" />
  <style>
    .right-separate {
      border-right: 3px double black;
    }
  </style>
</head>

<body>
  <header><a href="https://ryutaro-kodama.github.io/slides">＜ トップページへ戻る</a></header>
  <h1>Chapter3 Process Virtual Machines</h1>
  
  <div id="Overview">
    <h2>概要</h2>
    <p><strong>process VMの実装について見ていく</strong></p>
    <ul>
      <li>process VMはどんな要素から構成されるか(3.1)</li>
      <li>process VMはどんな要件が求められるか</li>
      <ul>
        <li>compatibility(互換性)</li>
        <li>compatibilityの"レベル"定義する(3.2.1)</li>
        <li>compatibilityを考えるにはどこに着目すればいいのか(3.2.2)</li>
      </ul>
      <li>process VMの細かい実装について</li>
      <ul>
        <li>guestとhostのstateのマッピング法とは(3.3)</li>
        <ul>
          <li>registerのマッピング法(3.3.1)</li>
          <li>memory address spaceのマッピング法(3.3.2)</li>
        </ul>
        <li>memory architectureのemulation法とは(3.4)</li>
        <ul>
          <li>memory protectionの実装方法(3.4.1)</li>
          <li>seklf-references/self-modifyingの扱い(3.4.2)</li>
        </ul>
      </ul>
    </ul>
  </div>

  <div id="Introduction">
    <h2>Introduction</h2>
    <ul>
      <li>本章ではprocess VMの視点からVMを見ていく</li>
      <ul>
        <li><img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/process_vm_structure.svg" width="400px"></li>
      </ul>
      <li>process VMのメリット</li>
      <ul>
        <li>ユーザーのホストシステム以外用に作られたプログラムも動かせる</li>
        <li>ex.)IA-32 アプリケーションをIA-64上で動かす</li>
      </ul>
      <li>一般的なprocess VM環境</li>
      <div class="flex">
        <div class="flex-left">
          <ul>
            <li>Host Process: Host system上で動くプロセス</li>
            <li>Guest Process: Host system上で動かないプロセス</li>
            <li>runtimeがGuest processをカプセル化</li>
            <ul>
              <li>一見host processと同じように見える</li>
              <li>host-guest, guest-guestのやり取りに違いがなくなる</li>
            </ul>
          </ul>
        </div>
        <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/guest_process_interacting_with_host_process.svg" width="400px" class="flex-right">
      </div>
    </ul>
    <strong>こういったprocess VMはどんな要素から構成される？</strong>
  </div>

  <div id="3.1 Virtual Machine Implementation">
    <h2>3.1 Virtual Machine Implementation</h2>
    <p>process VMの構造を見ていく</p>
    <svg x="0" y="0" width="720px" height="500px" style="background-color: #ddd">
      <marker id="marker-start" viewBox="-10 -5 10 10" refX="-10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
        <path d="M -10 0 L 0 -5 L 0 5 Z"/>
      </marker>
      <marker id="marker-end" viewBox="0 -5 10 10" refX="10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
        <path d="M 0 -5 L 0 5 L 10 0 Z"/>
      </marker>
      <!-- <line id="line1" x1="-50" y1="-50" x2="50" y2="50" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" stroke-dasharray="4 4"/> -->

      <rect x="30" y="40" width="100" height="50" stroke=black fill="#fff" />
      <text x="60" y="70">Loader</text>

      <polygon points="130 55, 185 55, 185 45, 200 65, 185 85, 185 75, 130 75" stroke="black" fill="#fff" />

      <rect x="200" y="25" width="150" height="80" rx="5" ry="5" stroke=black fill="#fff" />
      <text x="207" y="70">Guest Memory Image</text>

      <line id="L_I" x1="80" y1="90" x2="80" y2="140" stroke="black" marker-end="url(#marker-end)" stroke-width="1" />

      <rect x="20" y="140" width="120" height="50" stroke=black fill="#fff" />
      <text x="40" y="170">Initialization</text>

      <line id="GMI_EE" x1="275" y1="105" x2="275" y2="140" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
      <line id="I_EE" x1="140" y1="165" x2="210" y2="165" stroke="black" marker-end="url(#marker-end)" stroke-width="1" />

      <rect x="210" y="140" width="130" height="110" stroke=black fill="#fff" />
      <text x="220" y="170">Emulation Engine</text>
      <line x1="210" y1="190" x2="295" y2="190" stroke="black" stroke-width="1" />
      <text x="220" y="210">Translator</text>
      <line x1="210" y1="220" x2="295" y2="220" stroke="black" stroke-width="1" />
      <text x="220" y="240">Interpreter</text>
      <line x1="295" y1="250" x2="295" y2="190" stroke="black" stroke-width="1" />
      
      <line id="EE_PD" x1="210" y1="220" x2="180" y2="255" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
      
      <rect x="110" y="230" width="70" height="50" rx="5" ry="5" stroke=black fill="#fff" />
      <text x="125" y="250">Profile</text>
      <text x="130" y="270">Data</text>

      <line id="EE_CCM" x1="340" y1="220" x2="390" y2="220" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

      <rect x="390" y="190" width="130" height="60" stroke=black fill="#fff" />
      <text x="420" y="215">Code Cache</text>
      <text x="430" y="235">Manager</text>

      <line id="CCM_CC" x1="520" y1="220" x2="570" y2="220" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
      <line id="EE_CC" x1="340" y1="170" x2="570" y2="170" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

      <rect x="570" y="140" width="130" height="110" rx="5" ry="5" stroke=black fill="#fff" />
      <text x="600" y="200">Code Cache</text>

      <line id="EE_OCE" x1="275" y1="250" x2="275" y2="300" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

      <rect x="210" y="300" width="130" height="60" stroke=black fill="#fff" />
      <text x="220" y="335">OS Call Emulator</text>

      <line id="EE_EE" x1="340" y1="250" x2="390" y2="300" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

      <rect x="390" y="300" width="130" height="60" stroke=black fill="#fff" />
      <text x="425" y="325">Exception</text>
      <text x="425" y="345">Emulation</text>

      <line id="EE_EST" x1="520" y1="330" x2="570" y2="330" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

      <rect x="570" y="305" width="90" height="50" rx="5" ry="5" stroke=black fill="#fff" />
      <text x="585" y="325">Exception</text>
      <text x="580" y="345">Side Tables</text>
      
      <line id="I_HOS" x1="80" y1="190" x2="80" y2="410" stroke="black" stroke-style="dashed" marker-end="url(#marker-end)" stroke-width="1" stroke-dasharray="4"/>
      <text x="25" y="280">Initialize</text>
      <text x="25" y="300">signals</text>
      <line id="OSE_HOS" x1="275" y1="360" x2="275" y2="410" stroke="black" stroke-style="dashed" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
      <line id="EE_HOS" x1="455" y1="360" x2="455" y2="410" stroke="black" stroke-style="dashed" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

      <rect x="20" y="410" width="680" height="50" stroke=black fill="#fff" />
      <text x="300" y="440">Host Operation System</text>
    </svg>
    <div class="flex" style="border-top: 1px dashed black; padding: 10px 0px;">
      <svg x="0" y="0" width="720px" height="500px" class="flex-left" style="background-color: #ddd">
        <marker id="marker-start" viewBox="-10 -5 10 10" refX="-10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
          <path d="M -10 0 L 0 -5 L 0 5 Z"/>
        </marker>
        <marker id="marker-end" viewBox="0 -5 10 10" refX="10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
          <path d="M 0 -5 L 0 5 L 10 0 Z"/>
        </marker>
        <!-- <line id="line1" x1="-50" y1="-50" x2="50" y2="50" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" stroke-dasharray="4 4"/> -->
  
        <rect x="30" y="40" width="100" height="50" stroke="red" stroke-width="2" fill="#fff" />
        <text x="60" y="70">Loader</text>
  
        <polygon points="130 55, 185 55, 185 45, 200 65, 185 85, 185 75, 130 75" stroke="red" stroke-width="2" fill="#fff" />
  
        <rect x="200" y="25" width="150" height="80" rx="5" ry="5" stroke="red" stroke-width="2" fill="#fff" />
        <text x="207" y="70">Guest Memory Image</text>
  
        <line id="L_I" x1="80" y1="90" x2="80" y2="140" stroke="black" marker-end="url(#marker-end)" stroke-width="1" />
  
        <rect x="20" y="140" width="120" height="50" stroke=black fill="#fff" />
        <text x="40" y="170">Initialization</text>
  
        <line id="GMI_EE" x1="275" y1="105" x2="275" y2="140" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        <line id="I_EE" x1="140" y1="165" x2="210" y2="165" stroke="black" marker-end="url(#marker-end)" stroke-width="1" />
  
        <rect x="210" y="140" width="130" height="110" stroke=black fill="#fff" />
        <text x="220" y="170">Emulation Engine</text>
        <line x1="210" y1="190" x2="295" y2="190" stroke="black" stroke-width="1" />
        <text x="220" y="210">Translator</text>
        <line x1="210" y1="220" x2="295" y2="220" stroke="black" stroke-width="1" />
        <text x="220" y="240">Interpreter</text>
        <line x1="295" y1="250" x2="295" y2="190" stroke="black" stroke-width="1" />
        
        <line id="EE_PD" x1="210" y1="220" x2="180" y2="255" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        
        <rect x="110" y="230" width="70" height="50" rx="5" ry="5" stroke=black fill="#fff" />
        <text x="125" y="250">Profile</text>
        <text x="130" y="270">Data</text>
  
        <line id="EE_CCM" x1="340" y1="220" x2="390" y2="220" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
  
        <rect x="390" y="190" width="130" height="60" stroke=black fill="#fff" />
        <text x="420" y="215">Code Cache</text>
        <text x="430" y="235">Manager</text>
  
        <line id="CCM_CC" x1="520" y1="220" x2="570" y2="220" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        <line id="EE_CC" x1="340" y1="170" x2="570" y2="170" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
  
        <rect x="570" y="140" width="130" height="110" rx="5" ry="5" stroke=black fill="#fff" />
        <text x="600" y="200">Code Cache</text>
  
        <line id="EE_OCE" x1="275" y1="250" x2="275" y2="300" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
  
        <rect x="210" y="300" width="130" height="60" stroke=black fill="#fff" />
        <text x="220" y="335">OS Call Emulator</text>
  
        <line id="EE_EE" x1="340" y1="250" x2="390" y2="300" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
  
        <rect x="390" y="300" width="130" height="60" stroke=black fill="#fff" />
        <text x="425" y="325">Exception</text>
        <text x="425" y="345">Emulation</text>
  
        <line id="EE_EST" x1="520" y1="330" x2="570" y2="330" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
  
        <rect x="570" y="305" width="90" height="50" rx="5" ry="5" stroke=black fill="#fff" />
        <text x="585" y="325">Exception</text>
        <text x="580" y="345">Side Tables</text>
        
        <line id="I_HOS" x1="80" y1="190" x2="80" y2="410" stroke="black" stroke-style="dashed" marker-end="url(#marker-end)" stroke-width="1" stroke-dasharray="4"/>
        <text x="25" y="280">Initialize</text>
        <text x="25" y="300">signals</text>
        <line id="OSE_HOS" x1="275" y1="360" x2="275" y2="410" stroke="black" stroke-style="dashed" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        <line id="EE_HOS" x1="455" y1="360" x2="455" y2="410" stroke="black" stroke-style="dashed" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
  
        <rect x="20" y="410" width="680" height="50" stroke=black fill="#fff" />
        <text x="300" y="440">Host Operation System</text>
      </svg>
      <div class="flex-right" style="width: 300px;">
        <strong>事前準備</strong>
        <ul>
          <li>Loader -> Guest Memory Imageにguest codeとdataを書き込む</li>
          <li>(guest codeをそのまま実行するわけではない：</li>
          <ul>
            <li>runtimeからはguest codeもinput "data"と見ることができる)</li>
          </ul>
        </ul>
      </div>
    </div>
    <div class="flex" style="border-top: 1px dashed black; padding: 10px 0px;">
      <svg x="0" y="0" width="720px" height="500px" class="flex-left" style="background-color: #ddd">
        <marker id="marker-start" viewBox="-10 -5 10 10" refX="-10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
          <path d="M -10 0 L 0 -5 L 0 5 Z"/>
        </marker>
        <marker id="marker-end" viewBox="0 -5 10 10" refX="10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
          <path d="M 0 -5 L 0 5 L 10 0 Z"/>
        </marker>
        <!-- <line id="line1" x1="-50" y1="-50" x2="50" y2="50" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" stroke-dasharray="4 4"/> -->

        <rect x="30" y="40" width="100" height="50" stroke=black fill="#fff" />
        <text x="60" y="70">Loader</text>

        <polygon points="130 55, 185 55, 185 45, 200 65, 185 85, 185 75, 130 75" stroke="black" fill="#fff" />

        <rect x="200" y="25" width="150" height="80" rx="5" ry="5" stroke=black fill="#fff" />
        <text x="207" y="70">Guest Memory Image</text>

        <line id="L_I" x1="80" y1="90" x2="80" y2="140" stroke="black" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="20" y="140" width="120" height="50" stroke="red" stroke-width="2" fill="#fff" />
        <text x="40" y="170">Initialization</text>

        <line id="GMI_EE" x1="275" y1="105" x2="275" y2="140" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        <line id="I_EE" x1="140" y1="165" x2="210" y2="165" stroke="black" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="210" y="140" width="130" height="110" stroke=black fill="#fff" />
        <text x="220" y="170">Emulation Engine</text>
        <line x1="210" y1="190" x2="295" y2="190" stroke="black" stroke-width="1" />
        <text x="220" y="210">Translator</text>
        <line x1="210" y1="220" x2="295" y2="220" stroke="black" stroke-width="1" />
        <text x="220" y="240">Interpreter</text>
        <line x1="295" y1="250" x2="295" y2="190" stroke="black" stroke-width="1" />
        
        <line id="EE_PD" x1="210" y1="220" x2="180" y2="255" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        
        <rect x="110" y="230" width="70" height="50" rx="5" ry="5" stroke=black fill="#fff" />
        <text x="125" y="250">Profile</text>
        <text x="130" y="270">Data</text>

        <line id="EE_CCM" x1="340" y1="220" x2="390" y2="220" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="390" y="190" width="130" height="60" stroke=black fill="#fff" />
        <text x="420" y="215">Code Cache</text>
        <text x="430" y="235">Manager</text>

        <line id="CCM_CC" x1="520" y1="220" x2="570" y2="220" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        <line id="EE_CC" x1="340" y1="170" x2="570" y2="170" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="570" y="140" width="130" height="110" rx="5" ry="5" stroke=black fill="#fff" />
        <text x="600" y="200">Code Cache</text>

        <line id="EE_OCE" x1="275" y1="250" x2="275" y2="300" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="210" y="300" width="130" height="60" stroke=black fill="#fff" />
        <text x="220" y="335">OS Call Emulator</text>

        <line id="EE_EE" x1="340" y1="250" x2="390" y2="300" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="390" y="300" width="130" height="60" stroke=black fill="#fff" />
        <text x="425" y="325">Exception</text>
        <text x="425" y="345">Emulation</text>

        <line id="EE_EST" x1="520" y1="330" x2="570" y2="330" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="570" y="305" width="90" height="50" rx="5" ry="5" stroke=black fill="#fff" />
        <text x="585" y="325">Exception</text>
        <text x="580" y="345">Side Tables</text>
        
        <line id="I_HOS" x1="80" y1="190" x2="80" y2="410" stroke="red" stroke-style="dashed" marker-end="url(#marker-end)" stroke-width="1" stroke-dasharray="4"/>
        <text x="25" y="280">Initialize</text>
        <text x="25" y="300">signals</text>
        <line id="OSE_HOS" x1="275" y1="360" x2="275" y2="410" stroke="black" stroke-style="dashed" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        <line id="EE_HOS" x1="455" y1="360" x2="455" y2="410" stroke="black" stroke-style="dashed" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="20" y="410" width="680" height="50" stroke=black fill="#fff" />
        <text x="300" y="440">Host Operation System</text>
      </svg>
      <div class="flex-right" style="width: 300px;">
        <strong>Initialization</strong>
        <ul>
          <li>Initialization</li>
          <ul>
            <li>code cacheやtable等のためのメモリ領域を確保</li>
          </ul>
          <li>Host OSを呼び出し、signal handlerを扱えるようにする</li>
        </ul>
      </div>
    </div>
    <div class="flex" style="border-top: 1px dashed black; padding: 10px 0px;">
      <svg x="0" y="0" width="720px" height="500px" class="flex-left" style="background-color: #ddd">
        <marker id="marker-start" viewBox="-10 -5 10 10" refX="-10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
          <path d="M -10 0 L 0 -5 L 0 5 Z"/>
        </marker>
        <marker id="marker-end" viewBox="0 -5 10 10" refX="10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
          <path d="M 0 -5 L 0 5 L 10 0 Z"/>
        </marker>
        <!-- <line id="line1" x1="-50" y1="-50" x2="50" y2="50" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" stroke-dasharray="4 4"/> -->

        <rect x="30" y="40" width="100" height="50" stroke=black fill="#fff" />
        <text x="60" y="70">Loader</text>

        <polygon points="130 55, 185 55, 185 45, 200 65, 185 85, 185 75, 130 75" stroke="black" fill="#fff" />

        <rect x="200" y="25" width="150" height="80" rx="5" ry="5" stroke=black fill="#fff" />
        <text x="207" y="70">Guest Memory Image</text>

        <line id="L_I" x1="80" y1="90" x2="80" y2="140" stroke="black" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="20" y="140" width="120" height="50" stroke=black fill="#fff" />
        <text x="40" y="170">Initialization</text>

        <line id="GMI_EE" x1="275" y1="105" x2="275" y2="140" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        <line id="I_EE" x1="140" y1="165" x2="210" y2="165" stroke="black" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="210" y="140" width="130" height="110" stroke="red" stroke-width="2" fill="#fff" />
        <text x="220" y="170">Emulation Engine</text>
        <line x1="210" y1="190" x2="295" y2="190" stroke="red" stroke-width="2" stroke-width="1" />
        <text x="220" y="210">Translator</text>
        <line x1="210" y1="220" x2="295" y2="220" stroke="red" stroke-width="2" stroke-width="1" />
        <text x="220" y="240">Interpreter</text>
        <line x1="295" y1="250" x2="295" y2="190" stroke="red" stroke-width="2" stroke-width="1" />
        
        <line id="EE_PD" x1="210" y1="220" x2="180" y2="255" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        
        <rect x="110" y="230" width="70" height="50" rx="5" ry="5" stroke="black" fill="#fff" />
        <text x="125" y="250">Profile</text>
        <text x="130" y="270">Data</text>

        <line id="EE_CCM" x1="340" y1="220" x2="390" y2="220" stroke="red" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="390" y="190" width="130" height="60" stroke="red" stroke-width="2" fill="#fff" />
        <text x="420" y="215">Code Cache</text>
        <text x="430" y="235">Manager</text>

        <line id="CCM_CC" x1="520" y1="220" x2="570" y2="220" stroke="red" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        <line id="EE_CC" x1="340" y1="170" x2="570" y2="170" stroke="red" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="570" y="140" width="130" height="110" rx="5" ry="5" stroke="red" stroke-width="2" fill="#fff" />
        <text x="600" y="200">Code Cache</text>

        <line id="EE_OCE" x1="275" y1="250" x2="275" y2="300" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="210" y="300" width="130" height="60" stroke=black fill="#fff" />
        <text x="220" y="335">OS Call Emulator</text>

        <line id="EE_EE" x1="340" y1="250" x2="390" y2="300" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="390" y="300" width="130" height="60" stroke=black fill="#fff" />
        <text x="425" y="325">Exception</text>
        <text x="425" y="345">Emulation</text>

        <line id="EE_EST" x1="520" y1="330" x2="570" y2="330" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="570" y="305" width="90" height="50" rx="5" ry="5" stroke=black fill="#fff" />
        <text x="585" y="325">Exception</text>
        <text x="580" y="345">Side Tables</text>
        
        <line id="I_HOS" x1="80" y1="190" x2="80" y2="410" stroke="black" stroke-style="dashed" marker-end="url(#marker-end)" stroke-width="1" stroke-dasharray="4"/>
        <text x="25" y="280">Initialize</text>
        <text x="25" y="300">signals</text>
        <line id="OSE_HOS" x1="275" y1="360" x2="275" y2="410" stroke="black" stroke-style="dashed" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        <line id="EE_HOS" x1="455" y1="360" x2="455" y2="410" stroke="black" stroke-style="dashed" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="20" y="410" width="680" height="50" stroke=black fill="#fff" />
        <text x="300" y="440">Host Operation System</text>
      </svg>
      <div class="flex-right" style="width: 300px;">
        <strong>Emulation process</strong>
        <ul>
          <li>Emulation Engineがguest codeを変換</li>
          <li>変換されたコードはCode Cacheに保存</li>
          <li>(Code Cache ManagerがCode Cacheを管理)</li>
        </ul>
      </div>
    </div>
    <div class="flex" style="border-top: 1px dashed black; padding: 10px 0px;">
      <svg x="0" y="0" width="720px" height="500px" class="flex-left" style="background-color: #ddd">
        <marker id="marker-start" viewBox="-10 -5 10 10" refX="-10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
          <path d="M -10 0 L 0 -5 L 0 5 Z"/>
        </marker>
        <marker id="marker-end" viewBox="0 -5 10 10" refX="10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
          <path d="M 0 -5 L 0 5 L 10 0 Z"/>
        </marker>
        <!-- <line id="line1" x1="-50" y1="-50" x2="50" y2="50" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" stroke-dasharray="4 4"/> -->

        <rect x="30" y="40" width="100" height="50" stroke=black fill="#fff" />
        <text x="60" y="70">Loader</text>

        <polygon points="130 55, 185 55, 185 45, 200 65, 185 85, 185 75, 130 75" stroke="black" fill="#fff" />

        <rect x="200" y="25" width="150" height="80" rx="5" ry="5" stroke=black fill="#fff" />
        <text x="207" y="70">Guest Memory Image</text>

        <line id="L_I" x1="80" y1="90" x2="80" y2="140" stroke="black" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="20" y="140" width="120" height="50" stroke=black fill="#fff" />
        <text x="40" y="170">Initialization</text>

        <line id="GMI_EE" x1="275" y1="105" x2="275" y2="140" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        <line id="I_EE" x1="140" y1="165" x2="210" y2="165" stroke="black" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="210" y="140" width="130" height="110" stroke=black fill="#fff" />
        <text x="220" y="170">Emulation Engine</text>
        <line x1="210" y1="190" x2="295" y2="190" stroke="black" stroke-width="1" />
        <text x="220" y="210">Translator</text>
        <line x1="210" y1="220" x2="295" y2="220" stroke="black" stroke-width="1" />
        <text x="220" y="240">Interpreter</text>
        <line x1="295" y1="250" x2="295" y2="190" stroke="black" stroke-width="1" />
        
        <line id="EE_PD" x1="210" y1="220" x2="180" y2="255" stroke="red" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        
        <rect x="110" y="230" width="70" height="50" rx="5" ry="5" stroke="red" stroke-width="2" fill="#fff" />
        <text x="125" y="250">Profile</text>
        <text x="130" y="270">Data</text>

        <line id="EE_CCM" x1="340" y1="220" x2="390" y2="220" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="390" y="190" width="130" height="60" stroke=black fill="#fff" />
        <text x="420" y="215">Code Cache</text>
        <text x="430" y="235">Manager</text>

        <line id="CCM_CC" x1="520" y1="220" x2="570" y2="220" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        <line id="EE_CC" x1="340" y1="170" x2="570" y2="170" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="570" y="140" width="130" height="110" rx="5" ry="5" stroke=black fill="#fff" />
        <text x="600" y="200">Code Cache</text>

        <line id="EE_OCE" x1="275" y1="250" x2="275" y2="300" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="210" y="300" width="130" height="60" stroke=black fill="#fff" />
        <text x="220" y="335">OS Call Emulator</text>

        <line id="EE_EE" x1="340" y1="250" x2="390" y2="300" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="390" y="300" width="130" height="60" stroke=black fill="#fff" />
        <text x="425" y="325">Exception</text>
        <text x="425" y="345">Emulation</text>

        <line id="EE_EST" x1="520" y1="330" x2="570" y2="330" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="570" y="305" width="90" height="50" rx="5" ry="5" stroke=black fill="#fff" />
        <text x="585" y="325">Exception</text>
        <text x="580" y="345">Side Tables</text>
        
        <line id="I_HOS" x1="80" y1="190" x2="80" y2="410" stroke="black" stroke-style="dashed" marker-end="url(#marker-end)" stroke-width="1" stroke-dasharray="4"/>
        <text x="25" y="280">Initialize</text>
        <text x="25" y="300">signals</text>
        <line id="OSE_HOS" x1="275" y1="360" x2="275" y2="410" stroke="black" stroke-style="dashed" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        <line id="EE_HOS" x1="455" y1="360" x2="455" y2="410" stroke="black" stroke-style="dashed" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="20" y="410" width="680" height="50" stroke=black fill="#fff" />
        <text x="300" y="440">Host Operation System</text>
      </svg>
      <div class="flex-right" style="width: 300px;">
        <strong>Emulation process(Profile Data)</strong>
        <ul>
          <li>Profile Dataは動的にプログラム情報を集める</li>
          <li>最適化のために使う(詳しくは4章)</li>
        </ul>
      </div>
    </div>
    <div class="flex" style="border-top: 1px dashed black; padding: 10px 0px;">
      <svg x="0" y="0" width="720px" height="500px" class="flex-left" style="background-color: #ddd">
        <marker id="marker-start" viewBox="-10 -5 10 10" refX="-10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
          <path d="M -10 0 L 0 -5 L 0 5 Z"/>
        </marker>
        <marker id="marker-end" viewBox="0 -5 10 10" refX="10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
          <path d="M 0 -5 L 0 5 L 10 0 Z"/>
        </marker>
        <!-- <line id="line1" x1="-50" y1="-50" x2="50" y2="50" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" stroke-dasharray="4 4"/> -->

        <rect x="30" y="40" width="100" height="50" stroke=black fill="#fff" />
        <text x="60" y="70">Loader</text>

        <polygon points="130 55, 185 55, 185 45, 200 65, 185 85, 185 75, 130 75" stroke="black" fill="#fff" />

        <rect x="200" y="25" width="150" height="80" rx="5" ry="5" stroke=black fill="#fff" />
        <text x="207" y="70">Guest Memory Image</text>

        <line id="L_I" x1="80" y1="90" x2="80" y2="140" stroke="black" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="20" y="140" width="120" height="50" stroke=black fill="#fff" />
        <text x="40" y="170">Initialization</text>

        <line id="GMI_EE" x1="275" y1="105" x2="275" y2="140" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        <line id="I_EE" x1="140" y1="165" x2="210" y2="165" stroke="black" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="210" y="140" width="130" height="110" stroke=black fill="#fff" />
        <text x="220" y="170">Emulation Engine</text>
        <line x1="210" y1="190" x2="295" y2="190" stroke="black" stroke-width="1" />
        <text x="220" y="210">Translator</text>
        <line x1="210" y1="220" x2="295" y2="220" stroke="black" stroke-width="1" />
        <text x="220" y="240">Interpreter</text>
        <line x1="295" y1="250" x2="295" y2="190" stroke="black" stroke-width="1" />
        
        <line id="EE_PD" x1="210" y1="220" x2="180" y2="255" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        
        <rect x="110" y="230" width="70" height="50" rx="5" ry="5" stroke=black fill="#fff" />
        <text x="125" y="250">Profile</text>
        <text x="130" y="270">Data</text>

        <line id="EE_CCM" x1="340" y1="220" x2="390" y2="220" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="390" y="190" width="130" height="60" stroke=black fill="#fff" />
        <text x="420" y="215">Code Cache</text>
        <text x="430" y="235">Manager</text>

        <line id="CCM_CC" x1="520" y1="220" x2="570" y2="220" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        <line id="EE_CC" x1="340" y1="170" x2="570" y2="170" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="570" y="140" width="130" height="110" rx="5" ry="5" stroke=black fill="#fff" />
        <text x="600" y="200">Code Cache</text>

        <line id="EE_OCE" x1="275" y1="250" x2="275" y2="300" stroke="red" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="210" y="300" width="130" height="60" stroke="red" stroke-width="2" fill="#fff" />
        <text x="220" y="335">OS Call Emulator</text>

        <line id="EE_EE" x1="340" y1="250" x2="390" y2="300" stroke="red" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="390" y="300" width="130" height="60" stroke="red" stroke-width="2" fill="#fff" />
        <text x="425" y="325">Exception</text>
        <text x="425" y="345">Emulation</text>

        <line id="EE_EST" x1="520" y1="330" x2="570" y2="330" stroke="red" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="570" y="305" width="90" height="50" rx="5" ry="5" stroke=black fill="#fff" />
        <text x="585" y="325">Exception</text>
        <text x="580" y="345">Side Tables</text>
        
        <line id="I_HOS" x1="80" y1="190" x2="80" y2="410" stroke="black" stroke-style="dashed" marker-end="url(#marker-end)" stroke-width="1" stroke-dasharray="4"/>
        <text x="25" y="280">Initialize</text>
        <text x="25" y="300">signals</text>

        <line id="OSE_HOS" x1="275" y1="360" x2="275" y2="410" stroke="red" stroke-style="dashed" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        <line id="EE_HOS" x1="455" y1="360" x2="455" y2="410" stroke="red" stroke-style="dashed" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="20" y="410" width="680" height="50" stroke=black fill="#fff" />
        <text x="300" y="440">Host Operation System</text>
      </svg>
      <div class="flex-right" style="width: 300px;">
        <strong>Emulation process(system call/exception)</strong>
        <ul>
          <li>system call</li>
          <ul>
            <li>OS Call Emulatorが適切なcallに変換</li>
          </ul>
          <li>exception</li>
          <ul>
            <li>Exception Emulatorが適切に対処</li>
            <li>(EmulatorでのException、Host OSからのinterruptionともに対処)</li>
            <li>Exceptionが発生したときに正しいguestの状態を把握するのが大切</li>
          </ul>
        </ul>
      </div>
    </div>    <div class="flex" style="border-top: 1px dashed black; padding: 10px 0px;">
      <svg x="0" y="0" width="720px" height="500px" class="flex-left" style="background-color: #ddd">
        <marker id="marker-start" viewBox="-10 -5 10 10" refX="-10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
          <path d="M -10 0 L 0 -5 L 0 5 Z"/>
        </marker>
        <marker id="marker-end" viewBox="0 -5 10 10" refX="10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
          <path d="M 0 -5 L 0 5 L 10 0 Z"/>
        </marker>
        <!-- <line id="line1" x1="-50" y1="-50" x2="50" y2="50" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" stroke-dasharray="4 4"/> -->

        <rect x="30" y="40" width="100" height="50" stroke=black fill="#fff" />
        <text x="60" y="70">Loader</text>

        <polygon points="130 55, 185 55, 185 45, 200 65, 185 85, 185 75, 130 75" stroke="black" fill="#fff" />

        <rect x="200" y="25" width="150" height="80" rx="5" ry="5" stroke=black fill="#fff" />
        <text x="207" y="70">Guest Memory Image</text>

        <line id="L_I" x1="80" y1="90" x2="80" y2="140" stroke="black" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="20" y="140" width="120" height="50" stroke=black fill="#fff" />
        <text x="40" y="170">Initialization</text>

        <line id="GMI_EE" x1="275" y1="105" x2="275" y2="140" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        <line id="I_EE" x1="140" y1="165" x2="210" y2="165" stroke="black" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="210" y="140" width="130" height="110" stroke=black fill="#fff" />
        <text x="220" y="170">Emulation Engine</text>
        <line x1="210" y1="190" x2="295" y2="190" stroke="black" stroke-width="1" />
        <text x="220" y="210">Translator</text>
        <line x1="210" y1="220" x2="295" y2="220" stroke="black" stroke-width="1" />
        <text x="220" y="240">Interpreter</text>
        <line x1="295" y1="250" x2="295" y2="190" stroke="black" stroke-width="1" />
        
        <line id="EE_PD" x1="210" y1="220" x2="180" y2="255" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        
        <rect x="110" y="230" width="70" height="50" rx="5" ry="5" stroke=black fill="#fff" />
        <text x="125" y="250">Profile</text>
        <text x="130" y="270">Data</text>

        <line id="EE_CCM" x1="340" y1="220" x2="390" y2="220" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="390" y="190" width="130" height="60" stroke=black fill="#fff" />
        <text x="420" y="215">Code Cache</text>
        <text x="430" y="235">Manager</text>

        <line id="CCM_CC" x1="520" y1="220" x2="570" y2="220" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        <line id="EE_CC" x1="340" y1="170" x2="570" y2="170" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="570" y="140" width="130" height="110" rx="5" ry="5" stroke=black fill="#fff" />
        <text x="600" y="200">Code Cache</text>

        <line id="EE_OCE" x1="275" y1="250" x2="275" y2="300" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="210" y="300" width="130" height="60" stroke=black fill="#fff" />
        <text x="220" y="335">OS Call Emulator</text>

        <line id="EE_EE" x1="340" y1="250" x2="390" y2="300" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="390" y="300" width="130" height="60" stroke=black fill="#fff" />
        <text x="425" y="325">Exception</text>
        <text x="425" y="345">Emulation</text>

        <line id="EE_EST" x1="520" y1="330" x2="570" y2="330" stroke="red" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="570" y="305" width="90" height="50" rx="5" ry="5" stroke="red" stroke-width="2" fill="#fff" />
        <text x="585" y="325">Exception</text>
        <text x="580" y="345">Side Tables</text>
        
        <line id="I_HOS" x1="80" y1="190" x2="80" y2="410" stroke="black" stroke-style="dashed" marker-end="url(#marker-end)" stroke-width="1" stroke-dasharray="4"/>
        <text x="25" y="280">Initialize</text>
        <text x="25" y="300">signals</text>
        <line id="OSE_HOS" x1="275" y1="360" x2="275" y2="410" stroke="black" stroke-style="dashed" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
        <line id="EE_HOS" x1="455" y1="360" x2="455" y2="410" stroke="black" stroke-style="dashed" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />

        <rect x="20" y="410" width="680" height="50" stroke=black fill="#fff" />
        <text x="300" y="440">Host Operation System</text>
      </svg>
      <div class="flex-right" style="width: 300px;">
        <strong>Emulation process(Side Tables)</strong>
        <ul>
          <li>side table</li>
          <ul>
            <li>翻訳を補助するデータ構造</li>
            <li>ex.) Exception Side Tables</li>
            <ul>
              <li>source ISAでのexception処理をモデル化したもの</li>
            </ul>
          </ul>
        </ul>
      </div>
    </div>
    <p>ここからは、各要素の詳細について見ていく...</p>
    <p>その前にprocess VMの重要な要件であるhostとguestの<strong>Compatibility</strong>について考えていく</p>
  </div>

  <div id="3.2 Compatibility">
    <h2>3.2 Compatibility</h2>
    <ul>
      <li>VMの実装において一番重要なこと：</li>
      <ul>
        <li><strong>Compatibility(互換性)</strong></li>
        <li>host platformとguest native platformでのguestの振る舞いが同じか</li>
      </ul>
      <li>理想＝振る舞いが全く一緒</li>
      <ul>
        <li>実現が大変</li>
        <li>実用的には、完全なcompatibilityは必要ない</li>
      </ul>
      <li>compatibilityの定義に<strong>performanceは含めない</strong></li>
      <ul>
        <li>compatibilityとは正しい機能を有しているか、の問題</li>
        <li>どれだけ速い機能を有しているか、の問題ではない</li>
        <li>(ただしperformanceを全く考えない、わけではない...)</li>
      </ul>
      <!-- <li>この章では、(一般的なVM compatibility、)特にprocess level compatibilityに焦点を当てる</li>
      <ul>
        <li>ここからの議論や例題は、compatibilityとプログラムエミュレーションの観点から説明</li>
      </ul> -->
    </ul>

    <div id="3.2.1 Levels of Compatibility">
      <h3>3.2.1 Levels of Compatibility</h3>
      <ul>
        <li>Compatibilityの要件として、全時代の全プログラムに対する100%の正確性が必要か？</li>
        <ul>
          <li>NO!</li>
          <li>どの程度のCompatibilityが保証されているかに応じ、Compatibilityに"段階"をつける</li>
        </ul>
      </ul> <br>
      <table border="1">
        <thead>
          <tr>
            <th width="80px">-----</th>
            <th width="300px">intrinsic compatibility</th>
            <th width="300px">extrinsic compatibility</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>特徴</td>
            <td>
              <ul>
                <li>全てのguest softwareの全ての可能な入力"data"に対して動作可能</li>
                <li>ex.)マイクロプロセッサのISA互換性のためにハードウェア設計者が使用する標準規格</li>
              </ul>
            </td>
            <td>
              <ul>
                <li>VM上で動作できないプログラムがある</li>
                <ul>
                  <li>ex.) 特定のコンパイラでコンパイルされたプログラム</li>
                  <li>ex.) 特定のライブラリを使うプログラム</li>
                </ul>
              </ul>
            </td>
          </tr>
          <tr>
            <td>動作の保証</td>
            <td>追加の保証なしに、native platform上と同じように動くことが確約</td>
            <td>検証技術を用いて、誰かが保証してくれさえすれば動く</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div id="3.2.2 A Compatibility Framework">
      <h3>3.2.2 A Compatibility Framework</h3>
      <ul>
        <li>compatibilityの厳密な証明は難しい</li>
        <ul>
          <li>ex.) テストの繰り返し</li>
          <li>compatibilityについての"着目点"や"条件"が欲しい</li>
          <li>process VMを構造化</li>
          <ul>
            <li>各パーツについて"条件"を考える</li>
          </ul>
        </ul>
      </ul>
      <p style="border-top: 1px dashed black">
        compatibilityを考えるには、guestとhost間で「状態の対応関係」を考えたい<br>
        その「状態」を細分化しておく
      </p>
      <table align="center" border="1">
        <thead>
          <tr>
            <th>-----</th>
            <th width="420px">user-managed state</th>
            <th width="420px">OS-managed state</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>特徴</td>
            <td>user-level ISAによって操作される</td>
            <td>Host OSによって操作される</td>
          </tr>
          <tr>
            <td>例</td>
            <td>メインメモリーやレジスタ上のstate</td>
            <td>ディスクファイル等のストレージデバイス、ディスプレイやネットワーク状態に基づくもの</td>
          </tr>
          <tr>
            <td rowspan="2">State Mapping</td>
            <td>
              <ul>
                <li>扱いが簡単(guestからhostへの直線的なマッピング)</li>
                <li>両者の"型"が一致しなくてもよい</li>
                <ul>
                  <li>ex.) guest registerをhost memoryにマッピング</li>
                  <li>正しく対応関係が取れればOK</li>
                </ul>
              </ul>
            </td>
            <td>
              <ul>
                <li>扱いが難しい</li>
                <ul>
                  <li>state自体が様々な方法で管理されているため</li>
                  <li>stateへの操作もOSの機能で抽象化されているため</li>
                </ul>
              </ul>
            </td>
          </tr>
          <tr>
            <td colspan="2" align="center"><strong>guestをhostにマッピングするという、本質は同じ</strong></td>
          </tr>
        </tbody>
      </table>

      <h4>Operations</h4>
      <ul>
        <li>命令1つ1つ実行するごとに、guestとhostのstateの対応が等しいかを確認するのは大変</li>
        <li>あまりに確認の頻度が少ない</li>
        <ul>
          => 「disk writeするはずなのにしてなかった」
        </ul>
        <li>「外界とふれるところ」で確認を取れば大体OK(?)</li>
        <ul>
          ≒ (OSに)制御が移るところ
        </ul>
      </ul>
      <ul>
        <li>compatibility frameworkの大事なところ：</li>
        <ul>
          <li>user-managed stateとOS-managed state間でcontrol transfer point</li>
          <li>(注意点：native platformでOSを呼ぶ ≠ VM上でhost OSを呼ぶ)</li>
          <li><img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/correspondence_of_control_transfers.svg" alt=""></li>
        </ul>
        <li>process VMに課している要件(の1つ)</li>
        <ul>
          <li><strong>control transfer pointでの1対1のマッピングの確立</strong></li>
          <li>(大抵のprocess VMでは確立されている)</li>
        </ul>
        <!-- <li>以下、このマッピングがあれば、制御遷移地点でのstateが同等であることに注目</li> -->
      </ul>

      <h4>Sufficient Compatibility Conditions</h4>
      control transfer pointが分かる場合を仮定する。compatibilityに関する次の条件が与えられる。
      <ul>
        <li>control transfer pointでは、guest stateとhost stateが合っている</li>
        <ul>
          <li>＝「外界とふれるところ」でのみ確認すればいい</li>
          <li><img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/check_compatibility_on_control_transfer_point.svg" alt=""></li>
          <li>命令1つ1つ毎にマッピングが正しいか確認しなくてよい</li>
          <ul>
            <li>命令のemulationの仕方に自由度が生まれる</li>
            <ul>
              <li>命令の最適化をしても大丈夫</li>
            </ul>
          </ul>
          <li>注意点：「ユーザーが管理するすべての状態が外部に公開される可能性がある」という保守的な仮定がある</li>
          <ul>
            <li>メモリの一部を変更する場合でも、全てのメモリが等しいことを要求</li>
          </ul>
        </ul>
        <!-- <ul>
          <li>OSの動作の一部については、制御の遷移場所での状態と等しくなるような、operationの順番が必要なことがある</li>
          <ul>
            <li>graphics terminalやnetwork interfaceの駆動など</li>
          </ul>
        </ul> -->
      </ul>

      <h4>Discussion</h4>
      <ul>
        <li>前述の条件について</li>
        <ul>
          <li>「compatibilityの枠組みの条件」はVMが特定の方法で構造化されてる前提</li>
          <li>前述の条件はcompatibilityのための"十分条件"("必要条件"ではない)</li>
          <ul>
            <li>必ずしも満たされなくてもよい</li>
            <li>このような取り決めがあれば、簡単に問題が解決できることもある(ということが大事)</li>
          </ul>
        </ul>
        <li>intrinsicとextrinsicの違いは、compatibility frameworkの機能を用いて説明可能</li>
        <ul>
          <li>state mapping</li>
          <ul>
            <li>processの利用可能メモリ量には限界がある</li>
            <li>extrinsic compatibilityは、一定のサイズを超えないプロセスに対してのみ実現される</li>
          </ul>
        </ul>
      </ul>
    </div>

    <div id="3.2.3 Implementation Dependences">
      <h3>3.2.3 Implementation Dependences</h3>
      <ul>
        <li>機能が実装依存な場合、emulationを困難にすることがある</li>
        <li>ex.) self-modifying codeを実行した時のcacheの挙動</li>
        <details>
          <summary>いろいろな対策</summary>
          <ul>
            <li>cacheのupdateやflushを行わないプロセッサがある</li>
            <ul>
              <li>コンテキストスイッチ等のcacheに影響を与えるイベントにプログラムの結果が依存する(のでemulationしにくい)</li>
            </ul>
            <li>自分のソフトウェアを実行しているプロセッサの実装を正確に特定し、適切にcacheを管理するコードもある</li>
            <ul>
              <li>VM上にのみ存在してHostのものではないハードウェアを特定してしまうと、意図しない動作になる</li>
            </ul>
            <li>VMの実装を、自己修正コードを実行した時に必ずflushするようにすれば？</li>
            <ul>
              <li>ISAの仕様では、自己修正コードは、特定の命令を実行してキャッシュが明示的にフラッシュされた場合にのみ、その効果が保証され、そうでない場合は結果が不定になる</li>
              <li>適切にflushしない自己修正コードであっても、実際の実装では「動作する」ものがあるかもしれない</li>
              <li>明示的なflushを伴わない自己修正コードが、VM上で異なる動作をしてしまう</li>
            </ul>
          </ul>
        </details>
        <li>良い解決策はない</li>
        <ul>
          <li>VMの開発者はアーキテクチャやハードウェアの仕様を熟読してね</li>
        </ul>
      </ul>
    </div>
  </div>

  <div id="3.3 State Mapping">
    <h2>3.3 State Mapping</h2>
    <p>ここからVMの細かい実装を見ていく。まずはuser-managed stateのマッピングから</p>
    <div class="flex">
      <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/overview_of_state_mapping.svg" alt="" width="300px">
      <div>
        <p>stateのマッピングは例えば左図のようになる</p>
        <ul>
          <li>guest registerからhost registerへのマッピングは、runtime dataによって管理</li>
          <li>"memory" = 論理アドレス空間</li>
          <ul>
            ≠ 物理アドレス空間
          </ul>
        </ul>
      </div>
    </div>

    <div id="3.3.1 Register Mapping">
      <h3>3.3.1 Register Mapping</h3>
      <p>registerのマッピングは単純で、2.5章と2.8.1章で学んだ。ここでは要約のみ</p>
      <ul>
        <li>guest register数 ＜ host register数</li>
        <ul>
          <li>全てのguest registerをhost registerにマッピング可能</li>
          <li>emulationをしない時は、registerの内容をmemory(context block)に保存可能</li>
        </ul>
        <li>guest register数 ＝ host register数</li>
        <ul>
          <li>理論上は全てのguest registerをマッピング可能</li>
          <ul>
            <li>割り込み処理時等に追加のregisterが欲しいときに困るので、普通はやらない</li>
            <li>context blockへの保存時に、保存場所のアドレスが必要なため、余分なregisterが必要</li>
          </ul>
        </ul>
        <li>guest register数 ＞ host register数</li>
        <ul>
          <li>registerの一部はcontext blockに保存される</li>
          <li>runtimeがhost register空間を管理する</li>
        </ul>
      </ul>
    </div>

    <div id="3.3.2 Memory Address Space Mapping">
      <h3>3.3.2 Memory Address Space Mapping</h3>
      <ul>
        <li>guest address spaceをhost address spaceにマッピングするのは、runtimeの仕事</li>
        <ul>
          <li>
            <svg x="0" y="0" width="440px" height="130px" style="background-color: #ddd;">
              <marker id="marker-start" viewBox="-10 -5 10 10" refX="-10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
                <path d="M -10 0 L 0 -5 L 0 5 Z"/>
              </marker>
              <marker id="marker-end" viewBox="0 -5 10 10" refX="10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
                <path d="M 0 -5 L 0 5 L 10 0 Z"/>
              </marker>
              <!-- <line id="line1" x1="-50" y1="-50" x2="50" y2="50" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" stroke-dasharray="4 4"/> -->

              <polygon points="30 30, 100 30, 100 120, 30 120" stroke=black fill="#fff" />
              <text x="40" y="65">guest</text>
              <text x="40" y="85">program</text>

              <line id="line1" x1="100" y1="75" x2="175" y2="75" stroke="black" marker-end="url(#marker-end)" stroke-width="1" />
              <text x="105" y="65">store at A</text>

              <polygon points="175 30, 245 30, 245 120, 175 120" stroke=black fill="#fff" />
              <text x="185" y="80">runtime</text>
              
              <line id="line2" x1="245" y1="75" x2="320" y2="75" stroke="black" marker-end="url(#marker-end)" stroke-width="1" />
              <text x="250" y="65">store at A'</text>

              <polygon points="320 30, 395 30, 395 120, 320 120" stroke=black fill="#fff" />
              <text x="330" y="60">host</text>
              <text x="330" y="80">address</text>
              <text x="330" y="100">space</text>
            </svg>
          </li>
        </ul>
        <!-- <li>Just as with instruction emulation, there is a range of possibilities for performing address space mapping spanning different performance levels, determined by the relative amount of emulation performed by software compared to the amount performed directly on the host hardware</li>   -->
      </ul>
      <p>2種類の方法で、state mappingを実装する方法を見る</p>

      <h4>Runtime Software-Suppoerted Translation Tables</h4>
      <p><strong>(runtimeのsoftware主導のtranslation方法)</strong></p>
      <div class="flex">
        <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/software_translation_table.svg" alt="" width="250px" class="flex-left">
        <div class="flex-right">
          <ul>
            <li>memory architecture emulationの最も柔軟性に富む方法</li>
            <li>guest address spaceはブロックへ分割されて管理される</li>
            <ul>
              <li>各ブロックはhostの数ページ分に対応</li>
            </ul>
            <li>translation tableはruntimeに管理される</li>
            <!-- <li>guest addressはhost空間の隣接区域にマッピングされなくてもよい</li> -->
          </ul>
        </div>
      </div>
      <p>ex.) translation tableを使った、load命令emulation</p>
      <ul>
        <li>前提</li>
        <ul>
          <li>1blockは64KB(=2^16B)</li>
          <li>translation tableのbase addressはr30レジスタに格納されている</li>
          <li>guest(source) addressはr1レジスタに格納されている</li>
          <li>32bitアドレス空間</li>
        </ul>
        <li>着目点</li>
        <ul>
          <li>hostでもguestでも、block entry addressからのoffsetが同じ</li>
          <li><img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/load_emulation1.svg" alt="" width="700px"></li>
        </ul>
        <li>変換方法</li>
        <ul>
          <li><img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/load_emulation2.svg" alt="" width="700px"></li>
        </ul>
        <li>
          <details>
            <summary>どうして2bitズラす？</summary>
          <li><img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/load_emulation3.svg" alt="" width="700px"></li>
          </details>
        </li>
      </ul>
      <p>論理アドレスと物理アドレスの割り当てに似ている。。。</p>
      <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/mapping_guest2host_virtual2real.svg" alt="" width="550px">
      <ul>
        <li>guest memory blockがhost memory内に存在しないこともある</li>
        <div class="flex">
          <ul class="flex-left">
            <li>translation tableには、「アクセスされたguest blockがhost address space内に存在するか」を表す"valid" bitがある</li>
            <li>invalidの場合、memory managerがディスクとの間で入れ替えを行う</li>
            <ul>
              <li>これに伴いtranslation tableも変更</li>
            </ul>
          </ul>
          <table class="flex-right" border="1" style="border-collapse: collapse;">
            <thead>
              <th class="right-separate">guest address</th>
              <th>host address</th>
              <th>is in memory?</th>
            </thead>
            <tbody>
              <tr>
                <td class="right-separate">1111</td>
                <td>aaaa</td>
                <td>1</td>
              </tr>
              <tr>
                <td class="right-separate">2222</td>
                <td>bbbb</td>
                <td>0</td>
              </tr>
              <tr>
                <td class="right-separate">...</td>
                <td>...</td>
                <td>...</td>
              </tr>
            </tbody>
          </table>
        </div>
        <li>このようなstep-by-stepのsoftware-intensiveマッピングは、decode/dispach interpretationと概念的に似ている</li>
        <ul>
          <li>
            <div style="border: 1px dashed black;">
              <details>
                <summary style="color: red;"><strong>Q. どんなところが似ている？</strong></summary>
              </details>
            </div>
          </li>
          <li>binary translationでも有用だったりする</li>
          <li>オーバーヘッドは大きくなるが</li>
          <ul>
            <li>しかしstep-by-stepにsoftware-intensiveに行わなくてはならない場合もある</li>
            <!-- <li>ex.) 64bitのguest programを32bitのhost programでemulate</li> -->
          </ul>
          <li><strong>全ての方法が上手くいかないとき、step-by-stepのsoftware-intensive手法は有用</strong></li>
        </ul>
      </ul>

      <h4>Direct Translation Methods</h4>
      <p><strong>(次に、よりhardwareに任せたtranslation手法を見ていく)</strong></p>
      <ul>
        <li>特徴</li>
        <ul>
          <li>binary translationと似ている部分がある</li>
          <li>主に2つのパターンがある</li>
        </ul>
      </ul>
      <div class="flex">
        <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/offset_mapping.svg" alt="" width="270px">
        <ul>
          <strong>offset mapping</strong>
          <li>host address spaceがオフセット分だけずれている</li>
          <li>常に固定値分ずれているので、その固定値をhost registerで保持しておくことが有効</li>
        </ul>
      </div>
      <div class="flex">
        <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/direct_mapping.svg" alt="" width="270px">
        <ul>
          <strong>direct mapping</strong>
          <li>上図においてオフセットが0の場合</li>
          <li>runtime softwareはguest用に割り当てられた領域の上に置かれる</li>
          <li>guestとhostのアドレス変換は不要</li>
        </ul>
      </div>

      <h4>Compatibility Issues</h4>
      <p><strong>(様々なtranslation方法を見てきたが、compatibilityとの相性を考えていく)</strong></p>
      <ul>
        <li>guestとhostのアドレス空間の相対的な大きさは、マッピング方法の選択に重要な意味を持つ</li>
        <li>どの手法でも大事なこと：</li>
        <ul>
          <li>runtimeとguest上のアプリケーションが同じアドレス空間を共有すること</li>
          <li>"ちゃんとしないと"権限のない操作が行われてしまう</li>
        </ul>
      </ul>
      <div style="border: 1px dashed black;">
        <details>
          <summary style="color: red;"><strong>Q. intrinsic compatibilityとは</strong></summary>
        </details>
        <details>
          <summary style="color: red;"><strong>Q. extrinsic compatibilityとは</strong></summary>
        </details>
      </div>
      <ul>
        <li>intrinsic compatibilityを満たしたい場合(& high performance)</li>
        <ul>
          <li>guestのメモリ最大使用量とruntime softwareが収まるだけの空間をhost上に確保すべき</li>
          <ul>
            <!-- <li>この場合direct mappingを使うのがよい</li> -->
            <li>
              <svg x="0" y="0" width="400px" height="80px" style="background-color: #ddd;">
                <rect x="10px" y="15px" width="100px" height="50px" fill="#fff" stroke="#000" stroke-width="1px" />
                <rect x="110px" y="15px" width="150px" height="50px" fill="#fff" stroke="#000" stroke-width="1px" />
                <rect x="260px" y="15px" width="50px" height="50px" fill="red" stroke="#000" stroke-width="1px" />
                <text x="35" y="35px">runtime</text>
                <text x="33" y="50px">software</text>
                <text x="130" y="35px">guest's maximum</text>
                <text x="118" y="50px">memory consumption</text>
                <text x="275" y="43px">+α</text>
              </svg>
            </li>
            <li>ex.) IA-32をIA-64上でemulateするVM</li>
          </ul>
          <li>必要量が確保できないときも、下図のようなsoftware translation methodを使えば実現可能</li>
          <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/mapping_guest2host_virtual2real.svg" alt="" width="350px">
        </ul>
        <li>一方で、hostのABIに許可されている最大値までguestがメモリを使用することはあまりない</li>
        <svg x="0" y="0" width="400px" height="80px" style="background-color: #ddd;">
          <rect x="10px" y="15px" width="100px" height="50px" fill="#fff" stroke="#000" stroke-width="1px" />
          <rect x="110px" y="15px" width="150px" height="50px" fill="#fff" stroke="#000" stroke-width="1px" />
          <rect x="111px" y="16px" width="100px" height="48px" fill="rgb(0, 150, 256)" />
          <rect x="260px" y="15px" width="50px" height="50px" fill="red" stroke="#000" stroke-width="1px" />
          <text x="35" y="35px">runtime</text>
          <text x="33" y="50px">software</text>
          <text x="130" y="35px">guest's maximum</text>
          <text x="118" y="50px">memory consumption</text>
          <text x="275" y="43px">+α</text>
        </svg>
        <ul>
          <li>更に、特定のメモリサイズやメモリアドレスに依存するプログラムなどほぼない</li>
          <li>extrinsic compatibilityで十分</li>
          <ul>
            <li>「全プログラムに対して必要なメモリが確保でき、正しく動きます！」と保証されていなくても大丈夫</li>
            <li>runtimeを配置して残った容量を、guestの使用量が越えなければよい</li>
            <svg x="0" y="0" width="400px" height="240px" style="background-color: #ddd;">
              <rect x="10px" y="15px" width="330px" height="50px" fill="#fff" stroke="#000" stroke-width="1px" />
              <text x="130" y="45px">host memory</text>

              <rect x="10px" y="95px" width="100px" height="50px" fill="#fff" stroke="#000" stroke-width="1px" />
              <rect x="110px" y="95px" width="150px" height="50px" fill="rgb(0, 150, 256)" stroke="#000" stroke-width="1px" />
              <text x="35" y="115px">runtime</text>
              <text x="33" y="130px">software</text>
              <text x="135" y="125px">guest's memory</text>

              <rect x="10px" y="175px" width="100px" height="50px" fill="#fff" stroke="#000" stroke-width="1px" />
              <rect x="110px" y="175px" width="250px" height="50px" fill="red" stroke="#000" stroke-width="1px" />
              <text x="35" y="195px">runtime</text>
              <text x="33" y="210px">software</text>
              <text x="135" y="205px">guest's memory</text>

              <line x1="10" y1="65" x2="10" y2="95" stroke="black" stroke-dasharray="1" />
              <line x1="10" y1="225" x2="10" y2="95" stroke="black" stroke-dasharray="1" />
              <line x1="340" y1="65" x2="340" y2="225" stroke="black" stroke-dasharray="1" />
            </svg>
          </ul>
        </ul>
        <li>runtimeがposition independentな場合：</li>
        <ul>
          <li>効率的な変換が可能</li>
          <li>guest中のアプリケーションが使用している場所と衝突しないメモリ領域に自身を配置することが可能</li>
        </ul>
    </div>
  </div>

  <div id="3.4 Memory Architecture Emulation">
    <h2>3.4 Memory Architecture Emulation</h2>
    <p>process VMでemulateする必要があるmemory architectureの特徴はいくつかある</p>
    <ul>
      <li>アドレス空間の構造全体</li>
      <ul>
        <li>ex.) segmentに分かれているのか否か</li>
        <li>ここからはlinear address spaceで考える</li>
        <!-- <ul>
          <li>最新のABIで採用</li>
          <li>この上にセグメント分けされた論理メモリの技術がある</li>
        </ul> -->
      </ul>
      <li>アクセス権限</li>
      <ul>
        <li>ex.) あるメモリに対する(R, W, E)の権限を持っているか？</li>
      </ul>
      <li>protection/allocationの粒度</li>
      <ul>
        <li>OSが割り当てる最小のメモリブロックのサイズと、保護権限を維持する粒度</li>
      </ul>
    </ul>
    <p>まずは、「アドレス空間の構造全体」についての具体例</p>
    <div style="border: 1px dashed black; padding: 5px 20px;">
      ex.) Win32 ABI address space
      <div class="flex">
        <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/windows32_abi_address_space.svg" alt="" width="200px">
        <div class="flex-right">
          <table border="1">
            <tr>
              <th>Reserved by system</th>
              <td>システムに予約されている上下64KBずつ</td>
            </tr>
            <tr>
              <th>Reserved</th>
              <td>userが後に使用するために確保した場所</td>
            </tr>
            <tr>
              <th>Committed</th>
              <td>userが使用している場所</td>
            </tr>
            <tr>
              <th>Free</th>
              <td>ふり～</td>
            </tr>
          </table>
        </div>
      </div>
    </div>
    <ul>
      <li>重要な点：</li>
      <ul>
        <li>ユーザープロセスが非予約範囲内のすべてのアドレスへのアクセスを許可されること</li>
        <li><strong>あるメモリに対してアクセスできる"者"を区別する必要がある</strong></li>
      </ul>
    </ul>

    <div id="3.4.1 Memory Protection">
      <h3>3.4.1 Memory Protection</h3>
      <ul>
        <li>memory protectionはmemory architectureの重要な側面<br></li>
        <li>多くのISAでは異なる種類のアクセス制限を持っている</li>
        <ul>
          <li>これらの制限はread, write, executeで表される(ことが多い)</li>
        </ul>
      </ul>
      <ul>
        <li>software translation tableを使う場合</li>
        <ul>
          <li>保護チェックのemulationは簡単</li>
          <li>translation tableに保護情報を含んでおけば良い</li>
          <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/memory_protection_by_translation_table.svg" alt="">
          <ul>
            <li>論理メモリ構造に用いられている手法と同じ</li>
          </ul>
          <li>遅いという欠点がある</li>
        </ul>
        <li>direct/offset mappingを使う場合</li>
        <ul>
          <li>(translation tableがない)</li>
          <li>host OSの力を借りて実現する</li>
        </ul>
      </ul>      
      
      <h4>Host-Supported Memory Protection</h4>
      以下のようなhost OSが一般的に持つ機能を用いる
      <ul>
        <li>ページとアクセス権限を指定するシステムコール</li>
        <ul>
          <li>ex.) <code>mprotect()</code> system call</li>
        </ul>
        <li>アクセス権限に違反した場合にruntimeへ送られるシグナル</li>
        <ul>
          <li>ex.) <code>SIGSEGV</code> signal</li>
        </ul>
      </ul>
      <div class="flex">
        <div class="flex-left">
          他にも上のようなことを実現する方法はいろいろある<br>
          右図は<code>mmap()</code>を使った例
        </div>
        <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/mapping_memory_protection.svg" alt="" width="600px" style="margin-bottom: 20px;">
      </div>
      <span style="color: darkgrey;">(こういった便利な機能がなかったら...translation tableのような対応関係の取れるtableを作ればよい(けど効率は悪い))</span>

      <h4>Page Size Issues</h4>
      <p>ページサイズが違うと、memory protectionを行いにくい</p>
      <ul>
        <li>(1 guest page size) = n * (1 host page size)</li>
        <ul>
          <li>全てのhost pageに同じprotectを書ければいい</li>
          <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/page_size_issues1.svg" alt="" width="800px">
        </ul>
        <li>(1 guest page size) ＜ (1 host page size)</li>
        <ul>
          <li>1つのhost page内に複数のguest pageが入る</li>
          <li>guest page毎に権限が違うと困る</li>
          <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/page_size_issues2.svg" alt="" width="400px">
          <li>tableを作って細かく管理すれば(software-based mapping法を使えば)解決可能</li>
          <ul>
            <li>オーバーヘッドが大きくなる</li>
          </ul>
          <li>guest dataとguest codeの境界をhost page境界に持ってくれば？</li>
          <ul>
            <li>runtimeが位置の調節やアドレスの再変換をしなくてはならない</li>
            <li>emulationの効率が落ちる</li>
            <li>host page(host platform)依存になり、移植性が低下する</li>
          </ul>
          <li>host OSの力を借りる</li>
          <ul>
            <li>保守的なアプローチを取ると、「余分な」signalを処理する手間がかかる</li>
            <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/page_size_issues3.svg" alt="" width="800px">
          </ul>
        </ul>
      </ul>
      <p>protectの種類が違うことも問題</p>
      <ul>
        <li>hostがguestのprotectionの一部しかサポートしていないとき：</li>
        <ul>
          <li>VMは保守的なprotectの割り当てか、softwareによるチェックが必要</li>
        </ul>
        <li>ex.) hostが(R, W)、guestが(R, W, E)のとき：</li>
        <ul>
          <li>Interpretation</li>
          <ul>
            <li>software translation tableを介してチェック可能</li>
            <li>通常の動作の一部のため、減速はほとんどなし</li>
          </ul>
          <li>Binary translation</li>
          <ul>
            <li>runtimeが翻訳する際にguest codeのprotection checkをする必要がある</li>
            <li>アプリケーションがprotectを変更したら？</li>
            <ul>
              <li>OS call translation process (Section 3.7)で検知可能</li>
              <li>影響を受けた翻訳コードは破棄しなければならない</li>
            </ul>
          </ul>
        </ul>
      </ul>
    </div>

    <div id="3.4.2 Self-Referencing and Self-Modifying Code">
      <h3>3.4.2 Self-Referencing and Self-Modifying Code</h3>
      <ul>
        <li>アプリケーションプログラムは自分のcode regionから読み込んだり、書き込んだりする</li>
        <li>Binary translationでは問題が起こる</li>
        <ul>
          <li>オリジナルのソースコードが自分で読んだり書いたりした場合、翻訳されたバージョンでも全く同じ結果が得られなければならない</li>
        </ul>
        <li>self-referencing/self-modifyingどちらもやりたいことは同じ</li>
        <ul>
          <li><strong>guest program codeに対する正確なメモリイメージの維持</strong></li>
        </ul>
      </ul>

      <h4>Basic Method</h4>
      <ul>
        <div class="flex">
          <div class=flex-left>
            <li>翻訳後でのloadとstoreの対象アドレスは、sourceのメモリ領域にマッピングされる</li>
            <ul>
              <li>sourceのメモリ上のどこを参照しているかが分かる</li>
              <li>self-referencingは自動的に正しく実装できる</li>
            </ul>
          </div>
          <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/2021-05-27-23-51-07.png" alt="" class="flex-right" width="300px">
        </div>
        <div class="flex">
          <div class="flex-left" style="width: 850px">
            <div class="sticky">
              <li>self-modifyingに対しては？</li>
              <ul>
                <li>オリジナルのソースコードはruntimeにwrite-protectされている</li>
                <ul>
                  <li>翻訳されたすべてのコードに対してもwriteは禁止</li>
                </ul>
                <li>Interpretation modeでソースコードを書き換えてから、translation</li>
                <ol>
                  <li>書き込みを行おうとするとsignalが飛ぶ</li>
                  <li>runtimeは全てのcode cacheか、変更されるページに対応する翻訳をflush</li>
                  <li>対象のコード領域を一時的に書き込み可能にする</li>
                  <li>interpretation modeで書き換えていく</li>
                  <ul>
                    <li>faultが起きた地点を通るまで</li>
                  </ul>
                  <li>書き込み権限を戻し、translation再開</li>
                </ol>
              </ul>
            </div>
          </div>
          <div class="flex-right" style="flex-direction: column;">
            <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/2021-05-28-01-05-01.png" alt="" width="300px">
            <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/self_modifying_code_basic_method.svg" alt="" width="400px">
          </div>
        </div>
      </ul>

      <h4>Pseudo-Self-Modifying Code</h4>
      <ul>
        <li>上記のself-modifying codeへの対処方法はhigh-overhead</li>
        <li>(ただしself-modifying code自体が多くないのであまり問題ない)</li>
        <li>self-modifying codeやpseudo-self-modifying codeを頻繁に使う場合は深刻</li>
      </ul>
      <p>そこでpseudo-self-modifying codeを効率的に扱う方法を見ていく</p>
      <div class="flex">
        <div class="flex-left">
          <ul>
            <li>pseudo-self-modifying code：</li>
            <ul>
              <li>データ領域とコードが混在している状態</li>
              <li>コードを変更するつもりがない書き込みでも、書き込み禁止のエラーが発生してしまう</li>
              <li>device driverやgame kernel等に用いられる</li>
            </ul>
            <li>翻訳済みコードが実行される前に、ソースのコードが修正されたかどうかを動的にチェックする</li>
            <ol>
              <li>同じコード領域への書き込み保護フォールトが繰り返し発生した場合</li>
              <li>runtimeは書き込まれているページのコードを再翻訳し、元のソースコードをサイドテーブルに保存</li>
              <li>コードの現在のバージョンとサイド・テーブルのオリジナル・バージョンを比較</li>
              <li>書き込みたい場所の書き込み禁止をオフにしておく</li>
              <li>コードを変更していないと判断すれば（pseudo-self-modifying codeの場合）、翻訳されたコードを実行可能</li>
            </ol>
            <li>コードの比較に時間がかかるが、先の方法よりは高速</li>
          </ul>
        </div>
        <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/2021-05-28-02-15-21.png" alt="" class="flex-right" width="500px">
      </div>

      <h4>Fine-Grain Write-Protection</h4>
      <ul>
        <li>上記のprotect方式はページ単位でソースコード領域を保護</li>
        <ul>
          <li>余計な部分の翻訳されたソースコードまでflushしてしまう</li>
        </ul>
        <li>より細かい粒度でソースコードを保護する</li>
        <ul>
          <li>1ページを細分化し、各単位にbitで権限を表してテーブルで保存</li>
          <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/fine-grain_write-protection.svg" alt="">
        </ul>
      </ul>

      <h4>True Self-Modifying Code</h4>
      <ul>
        <li>(真の)self-modifying codeへの他の対処方法</li>
        <ul>
          <li>self-modifying codeの"よくあるパターン"の認識によって除去する</li>
          <ul>
            <li>ex.) 即値代入を行い、loopを実行</li>
            <li><img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/self_modifying_code_pattarn_recognition.svg" alt="" width="300px"></li>
          </ul>
        </ul>
        <li>変更される箇所が少ない場合</li>
        <ul>
          <li>ex.) デバイスに依存しないドライバ</li>
          <li>様々なソースコードのバージョンと、その翻訳結果のコードをペアで保存</li>
          <ul>
            <svg x=0 y=0 width=440 height=130 style="background-color: #ddd">
              <marker id="marker-start" viewBox="-10 -5 10 10" refX="-10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
                <path d="M -10 0 L 0 -5 L 0 5 Z"/>
              </marker>
              <marker id="marker-end" viewBox="0 -5 10 10" refX="10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
                <path d="M 0 -5 L 0 5 L 10 0 Z"/>
              </marker>
              
              <polygon points="30 20, 230 20, 230 50, 30 50" stroke=black fill="#fff" />
              <text x="40" y="40">not-modifyed-source-code</text>
              <polygon points="30 50, 230 50, 230 80, 30 80" stroke=black fill="#fff" />
              <text x="40" y="70">once-modifyed-source-code</text>
              <polygon points="30 80, 230 80, 230 110, 30 110" stroke=black fill="#fff" />
              <text x="40" y="100">twice-modifyed-source-code</text>
              
              <polygon points="280 20, 330 20, 330 50, 280 50" stroke=black fill="#fff" />
              <text x="290" y="40">1111</text>
              <polygon points="280 50, 330 50, 330 80, 280 80" stroke=black fill="#fff" />
              <text x="290" y="70">2222</text>
              <polygon points="280 80, 330 80, 330 110, 280 110" stroke=black fill="#fff" />
              <text x="290" y="100">3333</text>

              <line id="line1" x1="230" y1="35" x2="280" y2="35" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
              <line id="line2" x1="230" y1="65" x2="280" y2="65" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
              <line id="line3" x1="230" y1="95" x2="280" y2="95" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" />
            </svg>
          </ul>
          <li>オーバーヘッドは大きいが、再翻訳の繰り返しは避けられる</li>
        </ul>
      </ul>

      <h4>Protecting Runtime Memory</h4>
      <ul>
        <li>runtimeはguest上のアプリケーションと同じメモリ空間を共有している</li>
        <ul>
          <li>アプリケーションからruntimeへの書き込みを防がなくてはいけない</li>
        </ul>
        <li>software translation tableを用いている場合：</li>
        <ul>
          <li>tableにアクセス権限情報を付加すればよい</li>
          <ul>
            <li>(遅い)</li>
          </ul>
        </ul>
        <li>もっと速く行いたい</li>
        <ul>
          <li>ex.) Omniware VM</li>
          <!-- <details>
            <summary>ex.) Omniware VM</summary>
            <ul>
              <li>guest dataとcodeを2の累乗のsegment sizeに限定</li>
              <ul>
                <li>最後の1bitがフリー</li>
                <li>この1bitで書き込み権限を表す</li>
              </ul>
              <li>activeなsegmentが常に1つという仮定がある場合</li>
              <ul>
                <li>そのsegmentのアドレスをレジスタに保存</li>
              </ul>
              <li>その他諸々の技術を用いて、10%のオーバーヘッド削減</li>
              <li>「segment sizeを2の累乗に限定」によって追加のアドレス空間の制限が発生する可能性がある</li>
              <ul>
                <li>intrinsic compatibilityが失われる可能性がある</li>
              </ul>
            </ul>
          </details> -->
          <li>ex.) Dynamo System</li>
          <div class="flex">
            <div class="flex-left">

              <ul>
                <li>runtime modeとemulation modeの2つを用意しておく</li>
                <ul>
                  <li>emulation mode</li>
                  <ul>
                    <li>翻訳されたcodeを実行する</li>
                  </ul>
                  <li>runtime mode</li>
                  <ul>
                    <li>そのほかの時間</li>
                    <li>binary translatorがcodeを生成する、など</li>
                  </ul>
                </ul>
                <li>
                  <details>
                    <summary>細かい話</summary>
                    <ul>
                      <li>modeの切り替えについて</li>
                      <ul>
                        <li><code>mprotect()</code>を用いて権限変更</li>
                        <li>runtime mode -> emulation mode</li>
                        <ul>
                          <li>切り替える直前に権限変更</li>
                        </ul>
                        <li>emulation mode -> runtime mode</li>
                        <ul>
                          <li>runtime modeに制御が戻ると権限変更</li>
                        </ul>
                        <li>emulation中のソフトウェアがruntime領域にジャンプしようとしたら？</li>
                        <ul>
                          <li>Interpretationの場合</li>
                          <ul>
                            <li>ジャンプ先を明示的にチェックできる(から大丈夫)</li>
                          </ul>
                          <li>Binar translationの場合</li>
                          <ul>
                            <li>翻訳されたコードブロック内へのジャンプ</li>
                            <ul>
                              <li>直接アドレスで指定されるため、runtimeにジャンプしないとわかる</li>
                            </ul>
                            <li>翻訳されたコードブロックから出るジャンプ</li>
                            <ul>
                              <li>これは、翻訳ブロック内のマップテーブルやリンクポインタのいずれかを介して行われる</li>
                              <li>runtimeがこれらを書き込む。つまりruntimeが書き込んだ時に、とび先が大丈夫かチェック可能</li>
                            </ul>
                          </ul>
                        </ul>
                      </ul>
                    </ul>
                  </details>
                </li>
                <li>mode切り替えのオーバーヘッドが大きい</li>
                <ul>
                  <li>guest codeが変換されてcacheに保存されれば、大事ではない</li>
                </ul>
              </ul>
            </div>
            <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/protect_runtime_by_2mode.svg" alt="" class="right-flex" width="400px">
          </div>
        </ul>
        <li>memoryにマッピングされたregisterも守りたい</li>
        <ul>
          <li>intrinsic compatibilityの観点で考える：</li>
          <ul>
            <li>software protection checkingを用いる</li>
          </ul>
          <li>extrinsic compatibilityの観点で考える：</li>
          <ul>
            <li>「不正な領域への書き込みはない」ようなプログラムにする</li>
          </ul>
        </ul>
      </ul>
    </div>
  </div>
</body>

</html>

