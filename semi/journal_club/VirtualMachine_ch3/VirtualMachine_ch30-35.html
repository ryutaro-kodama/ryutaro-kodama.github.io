<!DOCTYPE html>
<html>

<head>
	<title></title>
	<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
	<link rel="stylesheet" type="text/css" href="https://ryutaro-kodama.github.io/slides/style/heading.css" />
	<link rel="stylesheet" type="text/css" href="https://ryutaro-kodama.github.io/slides/style/common.css" />
</head>

<body>
  <header><a href="https://ryutaro-kodama.github.io/slides">＜ トップページへ戻る</a></header>
  <h1>Chapter3 Process Virtual Machines</h1>
  
  <div id="Overview">
    <h2>概要</h2>
    <p><strong>process VMの実装について見ていく</strong></p>
    <ul>
      <li>process VMはどんな要素から構成されるか(3.1)</li>
      <li>process VMはどんな要件が求められるか</li>
      <ul>
        <li>compatibility(互換性)</li>
        <li>compatibilityの"レベル"定義する(3.2.1)</li>
        <li>compatibilityを考えるにはどこに着目すればいいのか(3.2.2)</li>
      </ul>
      <li>process VMの細かい実装について</li>
      <ul>
        <li>guestとhostのstateのマッピング法とは(3.3)</li>
        <ul>
          <li>registerのマッピング法(3.3.1)</li>
          <li>memory address spaceのマッピング法(3.3.2)</li>
        </ul>
        <li>memory architectureのemulation法とは(3.4)</li>
        <ul>
          <li>memory protectionの実装方法(3.4.1)</li>
        </ul>
      </ul>
    </ul>
  </div>

  <div id="Introduction">
    <h2>Introduction</h2>
    <ul>
      <li>本章ではprocess VMの視点からVMを見ていく</li>
      <ul>
        <li><img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/2021-05-26-09-55-21.png" width="400px"></li>
      </ul>
      <li>process VMのメリット</li>
      <ul>
        <li>ユーザーのホストシステム以外用に作られたプログラムも動かせる</li>
        <li>ex.)IA-32 アプリケーションをIA-64上で動かす</li>
      </ul>
      <li>一般的なprocess VM環境</li>
      <div class="flex">
        <div class="flex-left">
          <ul>
            
            <li>Host Process: Host system上で動くプロセス</li>
            <li>Guest Process: Host system上で動かないプロセス</li>
            <li>runtimeがGuest processをカプセル化</li>
            <ul>
              <li>一見host processと同じように見える</li>
              <li>host-guest, guest-guestのやり取りに違いがなくなる</li>
            </ul>
          </ul>
        </div>
        <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/2021-05-26-10-04-37.png" width="500px" class="flex-right">
      </div>
    </ul>
    <strong>こういったprocess VMはどんな要素から構成される？</strong>
  </div>

  <div id="3.1 Virtual Machine Implementation">
    <h2>3.1 Virtual Machine Implementation</h2>
    <p>process VMの構造を見ていく</p>
    <ol>
      <li>初期化に関する部分</li>
      <li>emulationに関する部分</li>
    </ol>
    <div class="flex" style="border-top: 1px dashed black; padding: 10px 0px;">
      <div>
        <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/process_VM_structure1-1.png" width="600px" height="450px">
      </div>
      <div>
        <strong>step 1-1</strong>
        <ul>
          <li>Loader -> Guest Memory Imageにguest codeとdataを書き込む</li>
          <li>(guest codeをそのまま実行するわけではないため、runtimeからはguest codeもinput "data"と見ることができる)</li>
        </ul>
      </div>
    </div>
    <div class="flex" style="border-top: 1px dashed black; padding: 10px 0px;">
      <div>
        <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/process_VM_structure1-2.png" width="600px" height="450px">
      </div>
      <div>
        <strong>step 1-2</strong>
        <ul>
          <li>Initialization</li>
          <ul>
            <li>code cacheやtable等のためのメモリ領域を確保</li>
          </ul>
          <li>Host OSを呼び出し、signal handlerを扱えるようにする</li>
        </ul>
      </div>
    </div>
    <div class="flex" style="border-top: 1px dashed black; padding: 10px 0px;">
      <div>
        <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/process_VM_structure2.png" width="600px" height="450px">
      </div>
      <div>
        <strong>step 2</strong>
        <ul>
          <li>Emulation Engineがguest codeを変換</li>
          <li>変換されたコードはCode Cacheに保存</li>
          <li>(Code Cacheの容量は小さいので、Code Cache ManagerがCode Cacheの管理を行う)</li>
        </ul>
      </div>
    </div>
    <div class="flex" style="border-top: 1px dashed black; padding: 10px 0px;">
      <div>
        <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/process_VM_structure2+.png" width="600px" height="450px">
      </div>
      <div>
        <strong>step 2+</strong>
        <ul>
          <li>Profile Dataは動的にプログラム情報を集める</li>
          <li>最適化のために使う(詳しくは4章)</li>
        </ul>
      </div>
    </div>
    <div class="flex" style="border-top: 1px dashed black; padding: 10px 0px;">
      <div>
        <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/process_VM_structure2-1.png" width="600px" height="450px">
      </div>
      <div>
        <strong>step 2-1</strong>
        <ul>
          <li>system call</li>
          <ul>
            <li>OS Call Emulatorが適切なcallに変換</li>
          </ul>
          <li>exception</li>
          <ul>
            <li>Exception Emulatorが適切に対処</li>
            <li>(EmulatoeでのException、Host OSからのinterruptionともに適切に対処)</li>
            <li>Exceptionが発生したときに正しいguestの状態にできるように気を配るのが大切</li>
          </ul>
        </ul>
      </div>
    </div>
    <div class="flex" style="border-top: 1px dashed black; padding: 10px 0px;">
      <div>
        <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/process_VM_structure2-2.png" width="600px" height="450px">
      </div>
      <div>
        <strong>step 2-2</strong>
        <ul>
          <li>side table</li>
          <ul>
            <li>翻訳を補助するデータ構造</li>
            <li>ex.) Exception Side Tables</li>
            <ul>
              <li>source ISAでのexception処理をモデル化したもの</li>
            </ul>
          </ul>
        </ul>
      </div>
    </div>
    <p>ここからは、各要素の詳細について見ていく...</p>
    <p>その前にprocess VMの重要な要件であるhostとguestの<strong>Compatibility</strong>について考えていく</p>
  </div>

  <div id="3.2 Compatibility">
    <h2>3.2 Compatibility</h2>
    <ul>
      <li>VMの実装において一番重要なこと：</li>
      <ul>
        <li><strong>Compatibility(互換性)</strong></li>
        <li>host platformとguest native platformでのguestの振る舞いが同じか</li>
      </ul>
      <li>理想＝振る舞いが全く一緒</li>
      <ul>
        <li>実現が大変</li>
        <li>実用的には、完全なcompatibilityは必要ない</li>
      </ul>
      <li>compatibilityの定義に<strong>performanceは含めない</strong></li>
      <ul>
        <li>compatibilityとは正しい機能を有しているか、の問題</li>
        <li>どれだけ速い機能を有しているか、の問題ではない</li>
        <li>(ただしperformanceを全く考えない、わけではない...)</li>
      </ul>
      <!-- <li>この章では、(一般的なVM compatibility、)特にprocess level compatibilityに焦点を当てる</li>
      <ul>
        <li>ここからの議論や例題は、compatibilityとプログラムエミュレーションの観点から説明</li>
      </ul> -->
    </ul>

    <div id="3.2.1 Levels of Compatibility">
      <h3>3.2.1 Levels of Compatibility</h3>
      <ul>
        <li>Compatibilityの要件として、全時代の全プログラムに対する100%の正確性が必要か？</li>
        <ul>
          <li>NO!</li>
          <li>どの程度のCompatibilityが保証されているかに応じ、Compatibilityに"段階"をつける</li>
        </ul>
      </ul> <br>
      <table border="1">
        <thead>
          <tr>
            <th width="80px">-----</th>
            <th width="300px">intrinsic compatibility</th>
            <th width="300px">extrinsic compatibility</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>特徴</td>
            <td>
              <ul>
                <li>全てのguest softwareの全ての可能な入力"data"に対して動作可能</li>
                <li>ex.)マイクロプロセッサのISA互換性のためにハードウェア設計者が使用する標準規格</li>
              </ul>
            </td>
            <td>
              <ul>
                <li>VM上で動作できないプログラムがある</li>
                <ul>
                  <li>ex.) 特定のコンパイラでコンパイルされたプログラム</li>
                  <li>ex.) 特定のライブラリを使うプログラム</li>
                </ul>
              </ul>
            </td>
          </tr>
          <tr>
            <td>動作の保証</td>
            <td>追加の保証なしに、native platform上と同じように動くことが確約</td>
            <td>検証技術を用いて、誰かが保証してくれさえすれば動く</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div id="3.2.2 A Compatibility Framework">
      <h3>3.2.2 A Compatibility Framework</h3>
      <ul>
        <li>compatibilityの厳密な証明は難しい</li>
        <ul>
          <li>compatibilityについての"着目点"や"条件"が欲しい</li>
          <li>process VMを構造化</li>
          <ul>
            <li>各パーツについて詳細を考える</li>
          </ul>
        </ul>
      </ul>
      <p>
        compatibilityとはguestとhost間で「状態の対応関係があるか」と考えることができる<br>
        その「状態」を細分化しておく
      </p>
      <table align="center" border="1">
        <thead>
          <tr>
            <th>-----</th>
            <th width="420px">user-managed state</th>
            <th width="420px">OS-managed state</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>特徴</td>
            <td>user-level ISAによって操作される</td>
            <td>Host OSによって操作される</td>
          </tr>
          <tr>
            <td>例</td>
            <td>メインメモリーやレジスタ上のstate</td>
            <td>ディスクファイル等のストレージデバイス、ディスプレイやネットワーク状態に基づくもの</td>
          </tr>
          <tr>
            <td rowspan="2">State Mapping</td>
            <td>
              <ul>
                <li>扱いが簡単(guestからhostへの直線的なマッピング)</li>
                <li>両者の"型"が一致しなくてもよい</li>
                <ul>
                  <li>ex.) guest registerをhost memoryにマッピング</li>
                  <li>正しく対応関係が取れればOK</li>
                </ul>
              </ul>
            </td>
            <td>
              <ul>
                <li>扱いが難しい</li>
                <ul>
                  <li>state自体が様々な方法で管理されているため</li>
                  <li>stateへの操作もOSの機能で抽象化されているため</li>
                </ul>
              </ul>
            </td>
          </tr>
          <tr>
            <td colspan="2" align="center"><strong>guestをhostにマッピングするという、本質は同じ</strong></td>
          </tr>
        </tbody>
      </table>

      <h4>Operations</h4>
      <ul>
        <li>命令1つ1つ実行するごとに、guestとhostのstateの対応が等しいかを確認するのは大変</li>
        <li>あまりに確認の頻度が少ない</li>
        <ul>
          => 「disk writeするはずなのにしてなかった」
        </ul>
        <li>「外界とふれるところ」で確認を取れば大体OK(?)</li>
        <ul>
          ≒ (OSに)制御が移るところ
        </ul>
      </ul>
      <ul>
        <li>compatibility frameworkの大事なところ：</li>
        <ul>
          <li>user-managed stateとOS-managed state間で制御が遷移する場所</li>
          <li>(注意点：native platformでOSを呼ぶ ≠ VM上でhost OSを呼ぶ)</li>
          <li><img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/2021-05-26-16-25-01.png" alt=""></li>
        </ul>
        <li>制御遷移地点での1対1のマッピングを確立することが、process VMに課している要件の一部</li>
        <ul>
          <li>(大抵のprocess VMでは確立されている)</li>
        </ul>
        <!-- <li>以下、このマッピングがあれば、制御遷移地点でのstateが同等であることに注目</li> -->
      </ul>

      <h4>Sufficient Compatibility Conditions</h4>
      制御の遷移に対応する場所が分かる場合を仮定する。compatibilityに関する次の条件が与えられる。
      <ol>
        <li>制御が移ったところのみ、guest stateとhost stateが合っているか確認しなければならない</li>
        <ul>
          <li>＝「外界とふれるところ」でのみ確認すればいい</li>
          <li><img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/2021-05-26-17-05-42.png" alt=""></li>
          <li>命令1つ1つ毎にマッピングが正しいか確認しなくてよい</li>
          <ul>
            <li>命令のemulationの仕方に自由度が生まれる</li>
            <ul>
              <li>命令の最適化をしても大丈夫</li>
            </ul>
          </ul>
          <li>注意点：「ユーザーが管理するすべての状態が外部に公開される可能性がある」という保守的な仮定がある</li>
          <ul>
            <li>メモリの一部を変更する場合でも、全てのメモリが等しいことを要求</li>
          </ul>
        </ul>

        <li>制御がuser instructionに戻った時点で、guest stateはhost stateと同等にならなければならない</li>
        <!-- <ul>
          <li>OSの動作の一部については、制御の遷移場所での状態と等しくなるような、operationの順番が必要なことがある</li>
          <ul>
            <li>graphics terminalやnetwork interfaceの駆動など</li>
          </ul>
        </ul> -->
      </ol>

      <h4>Discussion</h4>
      <ul>
        <li>前述の条件について</li>
        <ul>
          <li>「compatibilityの枠組みの条件」はVMが構造化されてる前提</li>
          <li>前述の条件はcompatibilityのための"十分条件"("必要条件でない")</li>
          <ul>
            <li>必ずしも満たされなくてもよい</li>
            <li>このような取り決めがあれば、簡単に問題が解決できることもある(ということが大事)</li>
          </ul>
        </ul>
        <li>intrinsicとextrinsicの違いは、compatibility frameworkの機能を用いて説明可能</li>
        <ul>
          <li>state mapping</li>
          <ul>
            <li>processの利用可能メモリ量には限界がある</li>
            <li>extrinsic compatibilityは、一定のサイズを超えないプロセスに対してのみ実現される</li>
          </ul>
        </ul>
      </ul>
    </div>

    <div id="3.2.3 Implementation Dependences">
      <h3>3.2.3 Implementation Dependences</h3>
      <ul>
        <li>機能が実装依存な場合、emulationを困難にすることがある</li>
        <li>ex.) 自己修正コードを実行した時のcacheの挙動</li>
        <ul>
          <li>cacheのupdateやflushを行わないプロセッサがある</li>
          <ul>
            <li>コンテキストスイッチ等のcacheに影響を与えるイベントにプログラムの結果が依存する</li>
          </ul>
          <li>自分のソフトウェアを実行しているプロセッサの実装を正確に特定し、適切にcacheを管理するコードもある</li>
          <ul>
            <li>VM上にのみ存在してHostのものではないハードウェアを特定してしまうと、意図しない動作になる</li>
          </ul>
          <li>VMの実装を、自己修正コードを実行した時に必ずflushするようにすれば？</li>
          <ul>
            <li>ISAの仕様では、自己修正コードは、特定の命令を実行してキャッシュが明示的にフラッシュされた場合にのみ、その効果が保証され、そうでない場合は結果が不定になる</li>
            <li>適切にflushしない自己修正コードであっても、実際の実装では「動作する」ものがあるかもしれない</li>
            <li>明示的なflushを伴わない自己修正コードが、VM上で異なる動作をしてしまう</li>
          </ul>
        </ul>
        <li>良い解決策はない</li>
        <ul>
          <li>VMの開発者はアーキテクチャやハードウェアの仕様を熟読してね</li>
        </ul>
      </ul>
    </div>
  </div>

  <div id="3.3 State Mapping">
    <h2>3.3 State Mapping</h2>
    <p>ここからVMの細かい実装を見ていく。まずはuser-managed stateのマッピングから</p>
    <div class="flex">
      <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/2021-05-27-00-23-17.png" alt="">
      <div>
        <p>stateのマッピングは例えば左図のようになる</p>
        <ul>
          <li>guest registerからhost registerへのマッピングは、runtime dataによって管理</li>
          <li>"memory" = 論理アドレス空間</li>
          <ul>
            ≠ 物理アドレス空間
          </ul>
        </ul>
      </div>
    </div>

    <div id="3.3.1 Register Mapping">
      <h3>3.3.1 Register Mapping</h3>
      <p>registerのマッピングは単純で、2.5章と2.8.1章で学んだ。ここでは要約のみ</p>
      <ul>
        <li>guest register数 ＜ host register数</li>
        <ul>
          <li>全てのguest registerをhost registerにマッピング可能</li>
          <li>runtimeはregisterの内容をmemory(context block)に保存している</li>
          <ul>
            <li>emulatorはemulation以外のタスク時は、registerの大部分を使用可能</li>
          </ul>
        </ul>
        <li>guest register数 ＝ host register数</li>
        <ul>
          <li>理論上は全てのguest registerをマッピング可能</li>
          <ul>
            <li>割り込み処理時等に追加のregisterが欲しいときに困るので、普通はやらない</li>
            <li>context blockへの保存時に、保存場所のアドレスが必要なため、余分なregisterが必要</li>
          </ul>
        </ul>
        <li>guest register数 ＞ host register数</li>
        <ul>
          <li>registerの一部はcontext blockに保存される</li>
          <li>runtimeがhost register 空間を管理する</li>
        </ul>
      </ul>
    </div>

    <div id="3.3.2 Memory Address Space Mapping">
      <h3>3.3.2 Memory Address Space Mapping</h3>
      <ul>
        <li>guest address spaceをhost address spaceにマッピングするのは、runtimeの仕事</li>
        <ul>
          <li>
            <svg x=0 y=0 width=440 height=150 style="background-color: #ddd">
              <marker id="marker-start" viewBox="-10 -5 10 10" refX="-10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
                <path d="M -10 0 L 0 -5 L 0 5 Z"/>
              </marker>
              <marker id="marker-end" viewBox="0 -5 10 10" refX="10" refY="0" markerWidth="10" markerHeight="10" orient="auto">
                <path d="M 0 -5 L 0 5 L 10 0 Z"/>
              </marker>
              <!-- <line id="line1" x1="-50" y1="-50" x2="50" y2="50" stroke="black" marker-start="url(#marker-start)" marker-end="url(#marker-end)" stroke-width="1" stroke-dasharray="4 4"/> -->

              <polygon points="30 30, 100 30, 100 120, 30 120" stroke=black fill="#fff" />
              <text x="40" y="65">guest</text>
              <text x="40" y="85">program</text>

              <line id="line1" x1="100" y1="75" x2="175" y2="75" stroke="black" marker-end="url(#marker-end)" stroke-width="1" />
              <text x="105" y="65">store at A</text>

              <polygon points="175 30, 245 30, 245 120, 175 120" stroke=black fill="#fff" />
              <text x="185" y="80">runtime</text>
              
              <line id="line2" x1="245" y1="75" x2="320" y2="75" stroke="black" marker-end="url(#marker-end)" stroke-width="1" />
              <text x="250" y="65">store at A'</text>

              <polygon points="320 30, 395 30, 395 120, 320 120" stroke=black fill="#fff" />
              <text x="330" y="60">host</text>
              <text x="330" y="80">address</text>
              <text x="330" y="100">space</text>
            </svg>
          </li>
        </ul>
        <!-- <li>Just as with instruction emulation, there is a range of possibilities for performing address space mapping spanning different performance levels, determined by the relative amount of emulation performed by software compared to the amount performed directly on the host hardware</li>   -->
      </ul>

      <h4>Runtime Software-Suppoerted Translation Tables</h4>
      <p><strong>(runtimeのsoftware主導のtranslation方法を見ていく)</strong></p>
      <p>memory architecture emulationの最も柔軟性に富む例</p>
      <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/2021-05-27-13-23-41.png" alt="" width="500px">
      <ul>
        <li>translation tableはruntimeに管理される</li>
        <!-- <li>guest addressはhost空間の隣接区域にマッピングされなくてもよい</li> -->
        <li>guest address spaceはブロックへ分割されて管理される</li>
        <ul>
          <li>各ブロックはhostの数ページ分に対応</li>
        </ul>
      </ul>
      <p>ex.) translation tableを使った、load命令emulation</p>
      <ul>
        <li>1blockは64KB(=2^16B)</li>
        <li>translation tableのbase addressはr30レジスタに格納されている</li>
        <li>guest(source) addressはr1レジスタに格納されている</li>
        <li>32bitアドレス空間</li>
      </ul>
      <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/how_to_load_mapping_memory.svg" alt="" width="650px">
      <p>論理アドレスと物理アドレスの割り当てに似ている。。。</p>
      <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/2021-05-27-15-04-30.png" alt="" width="650px">
      <ul>
        <li>guest memory blockがhost memory内に存在しないこともある</li>
        <ul>
          <li>translation tableには、「アクセスされたguest blockがhost address space内に存在するか」を表す"valid" bitがある</li>
          <li>invalidの場合、memory managerがディスクとの間で入れ替えを行う</li>
          <ul>
            <li>これに伴いtranslation tableも変更</li>
          </ul>
        </ul>
        <li>このようなstep-by-stepのsoftware-intensiveマッピングは、decode/dispach interpretationと概念的に似ている</li>
        <ul>
          <li>
            <div style="border: 1px dashed black;">
              <details>
                <summary style="color: red;"><strong>Q. どんなところが似ている？</strong></summary>
              </details>
            </div>
          </li>
          <li>その概念の有用性はinterpretationにとどまらない</li>
          <li>binary translationでも有用だったりする</li>
          <ul>
            <li>オーバーヘッドは大きくなるが</li>
            <li>しかしstep-by-stepにsoftware-intensiveに行わなくてはならない場合もある</li>
            <ul>
              <li>ex.) 64bitのguest programを32bitのhost programでemulate</li>
            </ul>
          </ul>
          <li><strong>全ての方法が上手くいかないとき、step-by-stepのsoftware-intensive手法は有用</strong></li>
        </ul>
      </ul>

      <h4>Direct Translation Methods</h4>
      <p><strong>(次に、よりhardwareに任せたtranslation手法を見ていく)</strong></p>
      <ul>
        <li>特徴</li>
        <ul>
          <li>binary translationと似ている部分がある</li>
          <li>主に2つのパターンがある</li>
        </ul>
      </ul>
      <div class="flex">
        <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/2021-05-27-16-07-11.png" alt="" height="200px">
        <ul>
          <strong>offset mapping</strong>
          <li>host address spaceがオフセット分だけずれている</li>
          <li>常に固定値分ずれているので、その固定値をhost registerで保持しておくことが有効</li>
        </ul>
      </div>
      <div class="flex">
        <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/2021-05-27-16-29-01.png" alt="" height="200px">
        <ul>
          <strong>direct mapping</strong>
          <li>上図においてオフセットが0の場合</li>
          <li>runtime softwareはguest用に割り当てられた領域の上に置かれる</li>
          <li>guestとhostのアドレス変換は不要</li>
        </ul>
      </div>

      <h4>Compatibility Issues</h4>
      <p><strong>(様々なtranslation方法を見てきたが、compatibilityとの相性を考えていく)</strong></p>
      <ul>
        <li>guestとhostのアドレス空間の相対的な大きさは、マッピング方法の選択に重要な意味を持つ</li>
        <li>(どんな手法でも大事なことは、runtimeとguest上のアプリケーションが同じアドレス空間を共有すること)</li>
        <ul>
          <li>"ちゃんとしないと"権限のない操作が行われてしまう</li>
        </ul>
      </ul>
      <div style="border: 1px dashed black;">
        <details>
          <summary style="color: red;"><strong>Q. intrinsic compatibilityとは</strong></summary>
        </details>
        <details>
          <summary style="color: red;"><strong>Q. extrinsic compatibilityとは</strong></summary>
        </details>
      </div>
      <ul>
        <li>intrinsic compatibilityを満たしたい場合(& high performance)</li>
        <ul>
          <div class="flex">
            <div style="width: 350px; margin-right: 30px;">
              <li>guestのメモリ最大使用量とruntime softwareが収まるだけの空間をhost上に確保すべき</li>
              <ul>
                <li>この場合direct mappingを使うのがよい</li>
                <li>ex.) IA-32をIA-64上でemulateするVM</li>
              </ul>
              <li>必要量が確保できないときも、図3.8のようなsoftware translation methodを使えば実現可能</li>
            </div>
            <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/2021-05-27-15-04-30.png" alt="" width="300px">
          </div>
        </ul>
        <li>一方で、hostのABIに許可されている最大値までguestがメモリを使用することはあまりない</li>
        <ul>
          <li>更に、特定のメモリサイズやメモリアドレスに依存するプログラムなどほぼない</li>
          <li>extrinsic compatibilityで十分</li>
          <ul>
            <li>「全プログラムに対して必要なメモリが確保できます！」と保証されていなくても大丈夫</li>
            <li>runtimeを配置して残った容量を、guestの使用量が越えなければよい</li>
            <li>runtimeがguest processに対して"戦略的に"配置されていれば、効率的な変換が可能</li>
            <ul>
              <li>戦略的：guest processが使用していない領域に配置すること</li>
              <li>≒ runtimeがposition independent</li>
              <ul>
                <li>guest中のアプリケーションが使用している場所と衝突しないメモリ領域に自身を配置することが可能</li>
                <li>アプリケーションが効率的に動作するための邪魔をしない</li>
              </ul>
            </ul>
          </ul>
        </ul>
      </ul>
    </div>
  </div>

  <div id="3.4 Memory Architecture Emulation">
    <h2>3.4 Memory Architecture Emulation</h2>
    <p>process VMでemulateする必要があるmemory architectureの特徴はいくつかある</p>
    <ul>
      <li>アドレス空間の構造全体</li>
      <ul>
        <li>ex.) segmentに分かれているのか否か</li>
        <li>ここからはlinear address spaceで考える</li>
        <!-- <ul>
          <li>最新のABIで採用</li>
          <li>この上にセグメント分けされた論理メモリの技術がある</li>
        </ul> -->
      </ul>
      <li>アクセス権限</li>
      <ul>
        <li>ex.) あるメモリに対する(R, W, E)の権限を持っているか？</li>
      </ul>
      <li>protection/allocationの粒度</li>
      <ul>
        <li>OSが割り当てる最小のメモリブロックのサイズと、保護権限を維持する粒度</li>
      </ul>
    </ul>
    <div style="border: 1px dashed black; padding: 5px 20px;">
      ex.) Win32 ABI address space
      <div class="flex">
        <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/2021-05-27-17-56-08.png" alt="" width="200px">
        <div class="flex-right">
          <table border="1">
            <tr>
              <th>Reserved by system</th>
              <td>システムに予約されている上下64KBずつ</td>
            </tr>
            <tr>
              <th>Reserved</th>
              <td>userが後に使用するために確保した場所</td>
            </tr>
            <tr>
              <th>Committed</th>
              <td>userが使用している場所</td>
            </tr>
            <tr>
              <th>Free</th>
              <td>ふり～</td>
            </tr>
          </table>
        </div>
      </div>
    </div>
    <p>
      重要な点は、ユーザープロセスが非予約範囲内のすべてのアドレスへのアクセスを許可されること<br>
      先に指摘したように、ランタイムはユーザープロセスとアドレス空間を透過的に共有しなければならない<br>
      つまり、<strong>あるメモリに対してアクセスできる"者"を区別する必要がある</strong>
    </p>

    <div id="3.4.1 Memory Protection">
      <h3>3.4.1 Memory Protection</h3>
      <ul>
        <li>memory protectionはmemory architectureの重要な側面<br></li>
        <li>多くのISAでは異なる種類のアクセス制限を持っている</li>
        <li>これらの制限はread, write, executeで表される(ことが多い)</li>
      </ul>
      <ul>
        <li>software translation tableを使う場合</li>
        <ul>
          <li>保護チェックのemulationは簡単</li>
          <li>translation tableに保護情報を含んでおけば良い</li>
          <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/memory_protection_by_translation_table.svg" alt="">
          <ul>
            <li>論理メモリ構造に用いられている手法と同じ</li>
          </ul>
          <li>遅いという欠点がある</li>
        </ul>
        <li>direct/offset mappingを使う場合</li>
        <ul>
          <li>(translation tableがない)</li>
          <li>host OSの力を借りて実現する</li>
        </ul>
      </ul>      
      
      <h4>Host-Supported Memory Protection</h4>
      以下のようなhost OSが一般的に持つ機能を用いる
      <ul>
        <li>ページとアクセス権限を指定するシステムコール</li>
        <ul>
          <li>ex.) mprotect() system call</li>
        </ul>
        <li>アクセス権限に違反した場合にruntimeへ送られるシグナル</li>
        <ul>
          <li>ex.) SIGSEGV signal</li>
        </ul>
      </ul>
      <div class="flex">
        <div class="flex-left">
          他にも上のようなことを実現する方法はいろいろある<br>
          右図はmmap()を使った例
        </div>
        <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/2021-05-27-22-10-54.png" alt="" width="600px" style="margin-bottom: 20px;">
      </div>
      <span style="color: darkgrey;">(こういった便利な機能がなかったら...translation tableのような対応関係の取れるtableを作ればよい(けど効率は悪い))</span>

      <h4>Page Size Issues</h4>
      <p>ページサイズが違うと、memory protectionを行いにくい</p>
      <ul>
        <li>(1 guest page size) = n * (1 host page size)</li>
        <ul>
          <li>全てのhost pageに同じprotectを書ければいい</li>
          <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/page_size_issues1.svg" alt="" width="800px">
        </ul>
        <li>(1 guest page size) ＜ (1 host page size)</li>
        <ul>
          <li>1つのhost page内に複数のguest pageが入る</li>
          <li>guest page毎に権限が違うと困る</li>
          <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/2021-05-27-22-39-04.png" alt="" width="650px">
          <li>tableを作って細かく管理すれば(software-based mapping法を使えば)解決できるが、オーバーヘッドが大きくなる</li>
          <li>guest dataとguest codeの教会をhost page境界に持ってくれば？</li>
          <ul>
            <li>runtimeが位置の調節やアドレスの再変換をしなくてはならない</li>
            <li>emulationの効率が落ちる</li>
            <li>host page(host platform)依存になり、移植性が低下する</li>
          </ul>
          <li>host OSの力を借りる</li>
          <ul>
            <li>保守的なアプローチを取ると、「余分な」signalを処理する手間がかかる</li>
            <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/page_size_issues3.svg" alt="" width="800px">
          </ul>
        </ul>
      </ul>
      <p>protectの種類が違うことも問題</p>
      <ul>
        <li>hostがguestのprotectionの一部しかサポートしていないとき：</li>
        <ul>
          <li>VMは保守的なprotectの割り当てか、softwareによるチェックが必要</li>
        </ul>
        <li>ex.) hostが(R, W)、guestが(R, W, E)のとき：</li>
        <ul>
          <li>Interpretation</li>
          <ul>
            <li>software translation tableを介してチェック可能</li>
            <li>通常の動作の一部のため、減速はほとんどなし</li>
          </ul>
          <li>Binary translation</li>
          <ul>
            <li>runtimeが翻訳する際にguest codeのprotection checkをする必要がある</li>
            <li>アプリケーションがprotectを変更したら？</li>
            <ul>
              <li>OS call translation process (Section 3.7)で検知可能</li>
              <li>影響を受けた翻訳コードは破棄しなければならない</li>
            </ul>
          </ul>
        </ul>
      </ul>
    </div>

    <div id="3.4.2 Self-Referencing and Self-Modifying Code">
      <h3>3.4.2 Self-Referencing and Self-Modifying Code</h3>
      <ul>
        <li>アプリケーションプログラムは自分のcode regionから読み込んだり、書き込んだりする</li>
        <li>Binary translationでは問題が起こる</li>
        <ul>
          <li>オリジナルのソースコードが自分で読んだり書いたりした場合、翻訳されたバージョンでも全く同じ結果が得られなければならない</li>
        </ul>
      </ul>

      <h4>Basic Method</h4>
      <ul>
        <li>self-referencing/self-modifyingどちらもやりたいことは同じ</li>
        <ul>
          <li><strong>guest program codeに対する正確なメモリイメージの維持</strong></li>
        </ul>
        <div class="flex">
          <div class=flex-left>
            <li>翻訳後でのloadとstoreの対象アドレスは、sourceのメモリ領域にマッピングされる</li>
            <ul>
              <li>sourceのメモリ上のどこを参照しているかが分かる</li>
              <li>self-referencingは自動的に正しく実装できる</li>
            </ul>
          </div>
          <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/2021-05-27-23-51-07.png" alt="" class="flex-right" width="300px">
        </div>
        <div class="flex">
          <div class="flex-left" style="width: 850px">
            <div class="sticky">
              <li>self-modifyingに対しては？</li>
              <ul>
                <li>オリジナルのソースコードはruntimeにwrite-protectされている</li>
                <ul>
                  <li>翻訳されたすべてのコードに対してもwriteは禁止</li>
                </ul>
                <li>書き込みを行おうとするとsignalが飛ぶ</li>
                <ol>
                  <li>runtimeは全てのcode cacheか、変更されるページに対応する翻訳をflush</li>
                  <li>対象のコード領域を一時的に書き込み可能にする</li>
                  <li>interpretation modeで書き換えていく</li>
                  <li>書き込み権限を戻す</li>
                </ol>
              </ul>
            </div>
          </div>
          <div class="flex-right" style="flex-direction: column;">
            <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/2021-05-28-01-05-01.png" alt="" width="300px">
            <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/self_modifying_code_basic_method.svg" alt="" width="400px">
          </div>
        </div>
      </ul>

      <h4>Pseudo-Self-Modifying Code</h4>
      <ul>
        <li>上記のself-modifying codeへの対処方法はhigh-overhead</li>
        <li>(ただしself-modifying code自体が多くないのであまり問題ない)</li>
        <li>self-modifying codeやpseudo-self-modifying codeを使う場合は深刻</li>
      </ul>
      <p>そこでpseudo-self-modifying codeの扱いを見ていく</p>
      <div class="flex">
        <div class="flex-left">
          <ul>
            <li>pseudo-self-modifying code：</li>
            <ul>
              <li>データ領域とコードが混在している状態</li>
              <li>コードを変更するつもりがない書き込みでも、書き込み禁止のエラーが発生してしまう</li>
              <li>device driverやgame kernel等に用いられる</li>
            </ul>
            <li>翻訳済みコードが実行される前に、ソースのコードが修正されたかどうかを動的にチェックする</li>
            <ol>
              <li>同じコード領域への書き込み保護フォールトが繰り返し発生した場合</li>
              <li>runtimeは書き込まれているページのコードを再翻訳し、元のソースコードをサイドテーブルに保存</li>
              <li>コードの現在のバージョンとサイド・テーブルのオリジナル・バージョンを比較</li>
              <li>書き込みたい場所の書き込み禁止をオフにしておく</li>
              <li>コードを変更していないと判断すれば（pseudo-self-modifying codeの場合）、翻訳されたコードを実行可能</li>
            </ol>
            <li>コードの比較に時間がかかるが、先の方法よりは高速</li>
          </ul>
        </div>
        <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/2021-05-28-02-15-21.png" alt="" class="flex-right" width="500px">
      </div>

      <h4>Fine-Grain Write-Protection</h4>
      <ul>
        <li>上記のprotect方式はページ単位でソースコード領域を保護</li>
        <ul>
          <li>余計な部分の翻訳されたソースコードまでflushしてしまう</li>
        </ul>
        <li>より細かい粒度でソースコードを保護する</li>
        <ul>
          <li>1ページを細分化し、各単位にbitで権限を表してテーブルで保存</li>
          <img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/fine-grain_write-protection.svg" alt="">
        </ul>
      </ul>

      <h4>True Self-Modifying Code</h4>
      <ul>
        <li>(真の)self-modifying codeへの他の対処方法</li>
        <ul>
          <li>self-modifying codeの"よくあるパターン"の認識によって除去する</li>
          <li><img src="https://ryutaro-kodama.github.io/slides/semi/journal_club/VirtualMachine_ch3/self_modifying_code_pattarn_recognition.svg" alt="" width="300px"></li>
        </ul>
        <li>変更される箇所が少ない場合</li>
        <ul>
          <li>ex.) デバイスに依存しないドライバ</li>
          <li>様々なソースコードのバージョンと、その翻訳結果のコードをペアで保存</li>
          <li>オーバーヘッドは大きいが、再翻訳の繰り返しは避けられる</li>
        </ul>
      </ul>

      <h4>Protecting Runtime Memory</h4>
      <ul>
        <li>runtimeはguest上のアプリケーションと同じメモリ空間を共有している</li>
        <ul>
          <li>アプリケーションからruntimeへの書き込みを防がなくてはいけない</li>
        </ul>
        <li>software translation tableを用いている場合：</li>
        <ul>
          <li>tableにアクセス権限情報を付加すればよい</li>
          <ul>
            <li>(遅い)</li>
          </ul>
        </ul>
        <li>もっと速く行いたい</li>
        <ul>
          <li>ex.) Omniware VM</li>
          <li>segment sizeを2の累乗に限定</li>
          <ul>
            <li>最後の1bitがフリー</li>
            <li>この1bitで書き込み権限を表す</li>
            <li></li>
          </ul>
          <li>activeなsegmentが常に1つという仮定がある場合</li>
          <ul>
            <li>そのsegmentのアドレスをレジスタに保存</li>
          </ul>
          <li>その他諸々の技術を用いて、10%のオーバーヘッド削減</li>
          <li>「segment sizeを2の累乗に限定」によって追加のアドレス空間の制限が発生する可能性がある</li>
          <ul>
            <li>intrinsic compatibilityが失われる可能性がある</li>
          </ul>
        </ul>
      </ul>


    </div>
  </div>
</body>

</html>

